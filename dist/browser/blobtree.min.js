!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three-full/builds/Three.cjs.js")))
: "function" == typeof define && define.amd
? define(["three-full/builds/Three.cjs.js"], e)
: (t.Blobtree = e(t.THREE));
})(this, function(t) {
"use strict";
t = t && t.hasOwnProperty("default") ? t.default : t;
var e,
i,
r = {
types: {},
register: function(t, e) {
if (this.types[t])
throw "Error : cannot register type " +
t +
", this name is already registered.";
this.types[t] = e;
},
fromJSON: function(t) {
var e = this.types[t.type];
if (!e)
throw "Error : type found in JSON (" +
t.type +
" is not registered in the Blobtree library.";
return e.fromJSON(t);
}
},
s = r,
o = 0,
n = function() {
(this.id = o++),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1),
(this.parentNode = null);
};
(n.prototype.constructor = n),
(n.type = "Element"),
s.register(n.type, n),
(n.prototype.toJSON = function() {
return {type: this.getType()};
}),
(n.prototype.getParentNode = function() {
return this.parentNode;
}),
(n.prototype.getType = function() {
return n.type;
}),
(n.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(n.prototype.computeAABB = function() {
throw "Error : computeAABB is abstract, should have been overwritten";
}),
(n.prototype.getAABB = function() {
return this.aabb;
}),
(n.prototype.isValidAABB = function() {
return this.valid_aabb;
}),
(n.prototype.invalidAABB = function() {
(this.valid_aabb = !1),
null !== this.parentNode &&
this.parentNode.isValidAABB() &&
this.parentNode.invalidAABB();
}),
(n.prototype.invalidAll = function() {
this.invalidAABB();
}),
(n.prototype.prepareForEval = function() {
throw "ERROR : prepareForEval is a virtual function, should be re-implemented in all element(error occured in Element.js";
}),
(n.prototype.value = function(t, e) {
throw "ERROR : value is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.numericalGradient = ((e = {v: 0}),
(i = ["x", "y", "z"]),
function(t, r, s) {
for (var o = s || 1e-5, n = 0; n < 3; ++n)
(t[i[n]] = t[i[n]] + o),
this.value(t, e),
(r[i[n]] = e.v),
(t[i[n]] = t[i[n]] - 2 * o),
this.value(t, e),
(r[i[n]] = (r[i[n]] - e.v) / (2 * o)),
(t[i[n]] = t[i[n]] + o);
})),
(n.prototype.getAreas = function() {
return [];
}),
(n.prototype.distanceTo = function(t) {
throw "ERROR : distanceTo is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.heuristicStepWithin = function() {
throw "ERROR : heuristicStepWithin is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(n.prototype.trim = function(t, e, i) {}),
(n.prototype.count = function(t) {
return 0;
});
var h = n,
a = function() {
h.call(this), (this.children = []);
};
((a.prototype = Object.create(h.prototype)).constructor = a),
(a.type = "Node"),
s.register(a.type, a),
(a.prototype.getType = function() {
return a.type;
}),
(a.prototype.toJSON = function() {
var t = h.prototype.toJSON.call(this);
t.children = [];
for (var e = 0; e < this.children.length; ++e)
t.children.push(this.children[e].toJSON());
return t;
}),
(a.prototype.prepareForEval = function() {
console.error(
"prepareForEval is a pure virtual function, should be reimplemented in every node class"
);
}),
(a.prototype.invalidAll = function() {
if ((this.invalidAABB(), this.children))
for (var t = 0; t < this.children.length; t++) this.children[t].invalidAll();
}),
(a.prototype.destroy = function() {
for (
var t = this.children.slice(0, this.children.length), e = 0;
e < t.length;
e++
)
t[e].destroy();
if (0 !== this.children.length) throw "Error : children length should be 0";
if (
(null !== this.parentNode && this.parentNode.removeChild(this),
null !== this.parentNode)
)
throw "Error : parent node should be null at this point";
this.children.length = 0;
}),
(a.prototype.addChild = function(t) {
null !== t.parentNode && t.parentNode.removeChild(t),
this.children.push(t),
(t.parentNode = this),
this.invalidAABB();
}),
(a.prototype.removeChild = function(t) {
for (var e = 0, i = this.children; i[e] !== t && e < i.length; ) ++e;
if (e == i.length) throw "c does not belong to the children of this node";
(i[e] = i[i.length - 1]), i.pop(), this.invalidAABB(), (t.parentNode = null);
}),
(a.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.children.length; t++)
this.children[t].computeAABB(), this.aabb.union(this.children[t].getAABB());
}),
(a.prototype.getAreas = function() {
if (!this.valid_aabb)
throw "Error : cannot call getAreas on a not prepared for eval nod, please call PrepareForEval first. Node concerned is a " +
this.getType();
for (var t = [], e = 0; e < this.children.length; e++)
t.push.apply(t, this.children[e].getAreas());
return t;
}),
(a.prototype.distanceTo = function(t) {
for (var e = 1e7, i = 0; i < this.children.length; i++)
e = Math.min(e, this.children[i].distanceTo(t));
return e;
}),
(a.prototype.heuristicStepWithin = function() {
for (var t = 1e7, e = 0; e < this.children.length; e++)
t = Math.min(t, this.children[e].heuristicStepWithin());
return t;
}),
(a.prototype.trim = function(t, e, i) {
for (var r = e.length, s = 0; s < this.children.length; s++)
this.children[s].getAABB().intersectsBox(t) ||
(e.push(this.children[s]), i.push(this));
for (s = r; s < e.length; ++s) this.removeChild(e[s]);
for (s = 0; s < this.children.length; s++) this.children[s].trim(t, e, i);
}),
(a.prototype.count = function(t) {
var e = 0;
this instanceof t && e++;
for (var i = 0; i < this.children.length; i++) e += this.children[i].count(t);
return e;
});
var p = a,
l = {};
(l.last_mov_pt = new t.Vector3()),
(l.grad = new t.Vector3()),
(l.eval_res_g = new t.Vector3(0, 0, 0)),
(l.eval_res = {v: 0, g: null}),
(l.vec = new t.Vector3()),
(l.safeNewton3D = function(t, e, i, r, s, o, n) {
n.copy(e);
for (var h = 1, a = 0, c = !1; 2 != a && h <= s && !c; ) {
if (
(this.last_mov_pt.copy(n),
(this.eval_res.g = this.eval_res_g),
t.value(n, this.eval_res),
this.grad.copy(this.eval_res.g),
0 !== this.grad.x || 0 !== this.grad.y || 0 !== this.grad.z)
) {
var p = this.grad.length(),
l = (i - this.eval_res.v) / p;
if (
(l < r && l > -r ? ((l = l > 0 ? r / p : -r / p), a++) : (a = 0),
this.grad.normalize().multiplyScalar(l),
n.add(this.grad),
this.vec.subVectors(n, e).lengthSq() > o * o)
)
return void n.copy(e);
} else c = !0;
++h;
}
c && n.copy(e);
}),
(l.safeNewton1D = function(e, i, r, s, o, n, h, a, c, p) {
if (((this.eval_res.g = this.eval_res_g), 0 === r.x && 0 === r.y && 0 === r.z))
throw "Error : search direction is null";
if (a <= 0)
throw "Error: epsilon <= 0, convergence will nuke your face or loop";
if (n < s || n > o) throw "Error : starting absc is not in boundaries";
for (var l = n, u = new t.Vector3(), v = 0, _ = 0; o - s > a && _ < c; )
e.value(
u
.copy(r)
.multiplyScalar(l)
.add(i),
this.eval_res
),
this.eval_res.v > h ? (s = l) : (o = l),
0 !== (v = this.eval_res.g.dot(r))
? ((l += (h - this.eval_res.v) / v) >= o || l <= s) && (l = 0.5 * (o + s))
: (l = 0.5 * (o + s)),
++_;
(p.p_absc = 0.5 * (o + s)),
p.p
.copy(r)
.multiplyScalar(l)
.add(i),
void 0 !== p.g &&
(0 === _ && e.value(p.p, this.eval_res), p.g.copy(this.eval_res.g));
}),
(l.dichotomy1D = function(e, i, r, s, o, n, h, a) {
this.eval_res.g = null;
var c = new t.Vector3().copy(i),
p = new t.Vector3(),
l = -(s /= 2),
u = l;
i.sub(p.copy(r).multiplyScalar(s));
for (var v = 0; s > n && v < h; )
v++,
c.copy(i),
(u = l),
(s /= 2),
e.value(i, this.eval_res),
this.eval_res.v < o
? (i.add(p.copy(r).multiplyScalar(s)), (l += s))
: (i.sub(p.copy(r).multiplyScalar(s)), (l -= s));
a.p.copy(i.add(c).divideScalar(2)),
(a.p_absc = (u + l) / 2),
a.p.copy(i),
(a.p_absc = l),
a.g &&
((this.eval_res.g = this.eval_res_g),
e.value(a.p, this.eval_res),
a.g.copy(this.eval_res.g));
});
var u = l,
v = function(e) {
e = e || {};
if (void 0 !== arguments[1])
throw "Error : Blobtree Material now takes only 1 argument.";
(this.color = new t.Color(void 0 !== e.color ? e.color : 11184810)),
(this.roughness = void 0 !== e.roughness ? e.roughness : 0),
(this.metalness = void 0 !== e.metalness ? e.metalness : 0);
};
(v.prototype.toJSON = function() {
return {
color: "#" + this.color.getHexString(),
roughness: this.roughness,
metalness: this.metalness
};
}),
(v.fromJSON = function(e) {
return new v({
color: new t.Color(e.color),
roughness: e.roughness,
metalness: e.metalness
});
}),
(v.prototype.clone = function() {
return new v({
color: this.color,
roughness: this.roughness,
metalness: this.metalness
});
}),
(v.prototype.copy = function(t) {
this.color.copy(t.color),
(this.roughness = t.roughness),
(this.metalness = t.metalness);
}),
(v.prototype.set = function(t, e, i) {
this.color.copy(t), (this.roughness = e), (this.metalness = i);
}),
(v.prototype.getColor = function() {
return this.color;
}),
(v.prototype.getRoughness = function() {
return this.roughness;
}),
(v.prototype.getMetalness = function() {
return this.metalness;
}),
(v.prototype.equals = function(t) {
return (
this.color.equals(t.color) &&
this.metalness === t.metalness &&
this.roughness === t.roughness
);
}),
(v.prototype.lerp = function(t, e) {
this.color.lerp(t.color, e),
(this.roughness = (1 - e) * this.roughness + e * t.roughness),
(this.metalness = (1 - e) * this.metalness + e * t.metalness);
}),
(v.prototype.triMean = function(t, e, i, r, s, o, n) {
return (
(this.color.r = (r * t.color.r + s * e.color.r + o * i.color.r) / n),
(this.color.g = (r * t.color.g + s * e.color.g + o * i.color.g) / n),
(this.color.b = (r * t.color.b + s * e.color.b + o * i.color.b) / n),
(this.roughness = (r * t.roughness + s * e.roughness + o * i.roughness) / n),
(this.metalness = (r * t.metalness + s * e.metalness + o * i.metalness) / n),
this
);
}),
(v.prototype.weightedMean = function(t, e, i) {
this.color.setRGB(0, 0, 0), (this.roughness = 0), (this.metalness = 0);
for (var r = void 0 === i ? t.length : i, s = 0, o = 0; o < r; ++o)
(this.color.r += e[o] * t[o].color.r),
(this.color.g += e[o] * t[o].color.g),
(this.color.b += e[o] * t[o].color.b),
(this.roughness += e[o] * t[o].roughness),
(this.metalness += e[o] * t[o].metalness),
(s += e[o]);
return (
0 !== s
? ((this.color.r /= s),
  (this.color.g /= s),
  (this.color.b /= s),
  (this.roughness /= s),
  (this.metalness /= s))
: ((this.color.r = 0),
  (this.color.g = 0),
  (this.color.b = 0),
  (this.roughness = 0),
  (this.metalness = 0)),
this
);
}),
(v.areEqualsArrays = function(t, e, i, r, s) {
console.warn(
"Material.areEqualsArrays is deprecated, please use your own comparison function using Material.equals."
);
for (var o = !0, n = 1; n < arguments.length; n++)
o =
o &&
((null === t && null === arguments[n]) ||
(null !== t && null !== arguments[n]));
if (!o) return o;
if (null === t) return !0;
for (n = 1; n < arguments.length; n++) {
var h = !0;
if (arguments[n].length !== t.length) return !1;
for (var a = 0; a < t.length; ++a) h = h && t[a].equals(arguments[n][a]);
o = o && h;
}
return o;
}),
(v.defaultMaterial = new v());
var _ = v,
m = function(e, i) {
if ((p.call(this), (this.ricci_n = e), i)) {
var r = this;
i.forEach(function(t) {
r.addChild(t);
});
}
(this.tmp_v_arr = new Float32Array(0)),
(this.tmp_m_arr = new Array(0)),
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new _());
};
((m.prototype = Object.create(p.prototype)).constructor = m),
(m.type = "RicciNode"),
s.register(m.type, m),
(m.prototype.getType = function() {
return m.type;
}),
(m.prototype.toJSON = function() {
var t = p.prototype.toJSON.call(this);
return (t.ricci = this.ricci_n), t;
}),
(m.fromJSON = function(t) {
for (var e = new m(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(s.fromJSON(t.children[i]));
return e;
}),
(m.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
if (((this.valid_aabb = !0), this.tmp_v_arr.length < this.children.length)) {
(this.tmp_v_arr = new Float32Array(2 * this.children.length)),
(this.tmp_m_arr.length = 2 * this.children.length);
for (e = 0; e < this.tmp_m_arr.length; ++e)
this.tmp_m_arr[e] = new _({roughness: 0, metalness: 0});
}
}
}),
(m.prototype.value = function(t, e) {
var i = this.children.length,
r = this.tmp_res;
if (
((r.g = e.g ? this.tmp_g : null),
(r.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(_.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
for (
var s = this.tmp_v_arr, o = this.tmp_m_arr, n = 0, h = 0, a = 0;
a < i;
++a
)
if (this.children[a].aabb.containsPoint(t))
if ((this.children[a].value(t, r), this.countEval++, r.v > 0)) {
var c = Math.pow(r.v, this.ricci_n - 1);
(h += r.v * c),
e.g && (r.g.multiplyScalar(c), e.g.add(r.g)),
e.m && ((s[n] = r.v * c), o[n].copy(r.m), n++),
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].heuristicStepWithin()));
} else
this.countEval0++,
e.step && (e.step = Math.min(e.step, this.children[a].distanceTo(t)));
else
(e.step || e.stepOrtho) &&
(e.step = Math.min(e.step, this.children[a].distanceTo(t)));
(e.v = Math.pow(h, 1 / this.ricci_n)),
0 !== e.v &&
(e.g && e.g.multiplyScalar(e.v / h), e.m && e.m.weightedMean(o, s, n));
} else e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
e.step && (e.stepOrtho = e.step);
}),
(m.prototype.setRicciN = function(t) {
this.ricci_n != t && ((this.ricci_n = t), this.invalidAABB());
}),
(m.prototype.getRicciN = function() {
return this.ricci_n;
});
var g,
y,
d,
f,
b,
w,
x,
V,
A = m,
S = function() {
A.call(this, 64),
(this.valid_aabb = !0),
(this.iso_value = 1),
(this.trimmed = []),
(this.trim_parents = []);
};
((S.prototype = Object.create(A.prototype)).constructor = S),
(S.type = "RootNode"),
s.register(S.type, S),
(S.prototype.getType = function() {
return S.type;
}),
(S.prototype.toJSON = function() {
var t = A.prototype.toJSON.call(this);
return (t.iso = this.iso_value), t;
}),
(S.fromJSON = function(t) {
for (var e = new S(t.ricci), i = 0; i < t.children.length; ++i)
e.addChild(s.fromJSON(t.children[i]));
return e;
}),
(S.prototype.getIsoValue = function() {
return this.iso_value;
}),
(S.prototype.setIsoValue = function(t) {
this.iso_value = t;
}),
(S.prototype.getNeutralValue = function() {
return 0;
}),
(S.prototype.invalidAABB = function() {
this.valid_aabb = !1;
}),
(S.prototype.internalTrim = function(t) {
if (0 !== this.trimmed.length || 0 !== this.trim_parents.length)
throw "Error : you should not call internal trim if you have not untrimmed before. Call untrim or use externalTrim";
this.trim(t, this.trimmed, this.trim_parents);
}),
(S.prototype.externalTrim = function(t, e, i) {
this.trim(t, e, i);
}),
(S.prototype.internalUntrim = function() {
this.untrim(this.trimmed, this.trim_parents),
(this.trimmed.length = 0),
(this.trim_parents.length = 0);
}),
(S.prototype.untrim = function(t, e) {
if (t.length !== e.length)
throw "Error : trimmed and parents arrays should have the same length";
for (var i = 0; i < t.length; ++i) e[i].addChild(t[i]);
}),
(S.prototype.isEmpty = function() {
return 0 == this.children.length;
}),
(S.prototype.intersectRayBlob = ((g = new t.Vector3()),
(y = new t.Vector3()),
(d = new t.Vector3()),
(f = {v: 0, g: new t.Vector3()}),
(b = {p: new t.Vector3(), g: new t.Vector3(), p_absc: 0}),
(w = 0),
(x = 0),
(V = 0),
function(t, e, i, r) {
for (
g.copy(t.origin),
y.copy(t.direction),
y.normalize(),
V = 0,
f.g = null,
this.value(g, f);
f.v < void 0 && V < i;

)
g.add(d.copy(y).multiplyScalar(f.step)),
(V += f.step),
(w = f.step),
(x = f.v),
this.value(g, f);
return (
f.v >= void 0 &&
(Convergence.safeNewton1D(
this,
g,
y.multiplyScalar(-1),
0,
w,
(w * (void 0 - f.v)) / (x - f.v),
void 0,
w / 512,
10,
b
),
(e.distance = V - b.absc),
(e.point = b.p.clone()),
e.g && e.g.copy(b.g),
!0)
);
})),
(S.prototype.intersectOrthoRayBlob = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
r = {step: 0},
s = new t.Vector3(),
o = {},
n = 0,
h = 0,
a = -1;
return function(t, c, p, l) {
for (
l.axis.z
? e.set(this.aabb.min.x + t, this.aabb.min.y + c, this.aabb.min.z + 1e-7)
: l.axis.y
? e.set(this.aabb.min.x + t, this.aabb.min.y + 1e-7, this.aabb.min.z + c)
: l.axis.z &&
  e.set(this.aabb.min.x + 1e-7, this.aabb.min.y + t, this.aabb.min.z + c),
r.step = l.get(this.aabb.max) - l.get(this.aabb.min),
this.value(e, r),
n = 1e-7,
a = -1;
l.get(e) < l.get(this.aabb.max);

) {
for (; (r.v - 1) * a >= 0 && l.get(e) < l.get(this.aabb.max); )
l.add(e, r.step),
(n = r.step),
(r.step = l.get(this.aabb.max) - l.get(e)),
this.value(e, r);
if (l.get(e) < l.get(this.aabb.max)) {
for (
a *= -1, i.copy(e), h = l.get(e), n /= 2, l.add(e, -n), o.g = null;
n > 0.1;

)
(h = l.get(e)),
(n /= 2),
this.value(e, o),
(o.v - 1) * a < 0 ? l.add(e, n) : l.add(e, -n);
l.add(e, h),
l.divide(e, 2),
(o.g = s),
this.value(e, o),
p.push({point: e.clone(), gradient: o.g.clone()}),
e.copy(i);
}
}
};
})());
var M = S,
T = function(e, i, r) {
p.call(this),
this.addChild(e),
this.addChild(i),
(this.alpha = r || 1),
(this.clamped = 0),
(this.tmp_res0 = {v: 0, g: new t.Vector3(0, 0, 0), m: new _()}),
(this.tmp_res1 = {v: 0, g: new t.Vector3(0, 0, 0), m: new _()}),
(this.g0 = new t.Vector3()),
(this.m0 = new _()),
(this.g1 = new t.Vector3()),
(this.m1 = new _()),
(this.tmp_v_arr = new Float32Array(2)),
(this.tmp_m_arr = [null, null]);
};
((T.prototype = Object.create(p.prototype)).constructor = T),
(T.type = "DifferenceNode"),
s.register(T.type, T),
(T.prototype.getAlpha = function() {
return this.alpha;
}),
(T.prototype.setAlpha = function(t) {
this.alpha != t && ((this.alpha = t), this.invalidAABB());
}),
(T.prototype.toJSON = function() {
var t = p.prototype.toJSON.call(this);
return (t.alpha = this.alpha), t;
}),
(T.fromJSON = function(t) {
var e = new T();
return (
(this.children[0] = s.fromJSON(t.children[0])),
(this.children[1] = s.fromJSON(t.children[1])),
e
);
}),
(T.prototype.prepareForEval = function() {
this.valid_aabb ||
(this.children[0].prepareForEval(),
this.children[1].prepareForEval(),
this.aabb.copy(this.children[0].getAABB()),
(this.valid_aabb = !0));
}),
(T.prototype.value = function(t, e) {
this.children.length;
var i = this.tmp_v_arr,
r = this.tmp_m_arr,
s = this.tmp_res0,
o = this.tmp_res1;
if (
((s.g = e.g ? this.g0 : null),
(s.m = e.m ? this.m0 : null),
(o.g = e.g ? this.g1 : null),
(o.m = e.m ? this.m1 : null),
(e.v = 0),
(o.v = 0),
(s.v = 0),
e.m &&
(e.m.copy(_.defaultMaterial),
o.m.copy(_.defaultMaterial),
s.m.copy(_.defaultMaterial)),
e.g
? (e.g.set(0, 0, 0), o.g.set(0, 0, 0), s.g.set(0, 0, 0))
: e.step && (e.step = 1e9),
this.aabb.containsPoint(t))
) {
if (this.children[0].aabb.containsPoint(t))
if (
(this.children[0].value(t, s),
this.children[1].aabb.containsPoint(t) && this.children[1].value(t, o),
0 === o.v)
)
(e.v = s.v), e.g && e.g.copy(s.g), e.m && e.m.copy(s.m);
else {
var n = Math.pow(o.v, this.alpha);
(e.v = Math.max(this.clamped, s.v - o.v * Math.pow(o.v, this.alpha - 1))),
e.g &&
(e.v === this.clamped
? e.g.set(0, 0, 0)
: (o.g.multiplyScalar(n), e.g.subVectors(s.g, o.g))),
e.m &&
((i[0] = s.v),
(i[1] = o.v),
(r[0] = s.m),
(r[1] = o.m),
e.m.weightedMean(r, i, 2));
}
} else e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
}),
(T.prototype.trim = function(t, e, i) {
for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
});
var B = T,
P = function(e) {
if ((p.call(this), e)) {
var i = this;
e.forEach(function(t) {
i.addChild(t);
});
}
(this.tmp_res = {v: 0, g: null, m: null}),
(this.tmp_g = new t.Vector3()),
(this.tmp_m = new _());
};
((P.prototype = Object.create(p.prototype)).constructor = P),
(P.type = "MinNode"),
s.register(P.type, P),
(P.prototype.getType = function() {
return P.type;
}),
(P.fromJSON = function(t) {
for (var e = new P(), i = 0; i < t.children.length; ++i)
e.addChild(s.fromJSON(t.children[i]));
return e;
}),
(P.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.getAABB());
}
this.valid_aabb = !0;
}
}),
(P.prototype.value = function(t, e) {
var i = this.children.length,
r = this.tmp_res;
if (
((r.g = e.g ? this.tmp_g : null),
(r.m = e.m ? this.tmp_m : null),
(e.v = 0),
e.m && e.m.copy(_.defaultMaterial),
e.g ? e.g.set(0, 0, 0) : e.step && (e.step = 1e9),
this.aabb.containsPoint(t) && 0 !== i)
) {
e.v = Number.MAX_VALUE;
for (var s = 0; s < i; ++s) {
if (
(this.children[s].value(t, r),
this.countEval++,
r.v < e.v &&
((e.v = r.v),
e.g && e.g.copy(r.g),
e.m && e.m.copy(r.m),
e.step || e.stepOrtho))
)
throw "Not implemented";
e.v = Math.min(e.v, r.v);
}
} else if (e.steo || e.stepOrtho) throw "Not implemented";
}),
(P.prototype.trim = function(t, e, i) {
for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
});
var k = P,
F = function() {
h.call(this), (this.materials = []);
};
((F.prototype = Object.create(h.prototype)).constructor = F),
(F.type = "Primitive"),
s.register(F.type, F),
(F.prototype.toJSON = function(t) {
var e = h.prototype.toJSON.call(this);
e.materials = [];
for (var i = 0; i < this.materials.length; ++i)
e.materials.push(this.materials[i].toJSON());
return e;
}),
(F.prototype.setMaterials = function(t) {
if (t.length !== this.materials.length)
throw "Error : trying to set " +
t.length +
" materials on a primitive with only " +
this.materials.length;
for (var e = 0; e < t.length; ++e)
t[e].equals(this.materials[e]) ||
(this.materials[e].copy(t[e]), this.invalidAABB());
}),
(F.prototype.getMaterials = function() {
return this.materials;
}),
(F.prototype.computeAABB = function() {
throw "Primitive.prototype.computeAABB  Must be reimplemented in all inherited class.";
}),
(F.prototype.destroy = function() {
null !== this.parentNode && this.parentNode.removeChild(this);
}),
(F.prototype.getAreas = function() {
throw "ERROR : getAreas is an abstract function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(F.prototype.computeHelpVariables = function() {
throw "ERROR : computeHelpVariables is a virtual function, should be re-implemented in all primitives(error occured in " +
this.getType() +
" primitive)";
}),
(F.prototype.count = function(t) {
return this instanceof t ? 1 : 0;
});
var N = F,
D = {KS: 2};
(D.KIS = 1 / D.KS),
(D.KS2 = 4),
(D.KIS2 = 1 / (D.KS * D.KS)),
(D.Poly6Eval = function(t) {
var e = 1 - D.KIS2 * t * t;
return e > 0 ? e * e * e : 0;
}),
(D.Poly6EvalSq = function(t) {
var e = 1 - D.KIS2 * t;
return e > 0 ? e * e * e : 0;
}),
(D.GetIsoValueAtDistanceGeom0D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
var r = 1 - (i * i) / (e * e);
return Math.pow(r, t / 2);
}
return 0;
}),
(D.Poly4NF0D = 1 / D.GetIsoValueAtDistanceGeom0D(4, D.KS, 1)),
(D.Poly6NF0D = 1 / D.GetIsoValueAtDistanceGeom0D(6, D.KS, 1)),
(D.GetIsoValueAtDistanceGeom1D = function(t, e, i) {
if (t % 2 != 0) throw "degree should be even";
if (i < e) {
for (var r = 1 - (i * i) / (e * e), s = 2 * e * Math.sqrt(r), o = 0; o != t; )
s *= ((o += 2) / (1 + o)) * r;
return s;
}
return 0;
}),
(D.Poly4NF1D = 1 / D.GetIsoValueAtDistanceGeom1D(4, D.KS, 1)),
(D.Poly6NF1D = 1 / D.GetIsoValueAtDistanceGeom1D(6, D.KS, 1)),
(D.GetIsoValueAtDistanceGeom2D = function(t, e, i) {
if (i < e) {
var r = t + 2,
s = 1 - (i * i) / (e * e);
return ((2 * Math.PI) / r) * e * e * Math.pow(s, 0.5 * r);
}
return 0;
}),
(D.Poly4NF2D = 1 / D.GetIsoValueAtDistanceGeom2D(4, D.KS, 1)),
(D.Poly6NF2D = 1 / D.GetIsoValueAtDistanceGeom2D(6, D.KS, 1));
var z = D,
O = function() {
N.call(this), (this.volType = O.DIST), (this.v = []);
};
(O.DIST = "dist"),
(O.CONVOL = "convol"),
(O.prototype = Object.create(N.prototype)),
(O.prototype.constructor = O),
(O.type = "ScalisPrimitive"),
s.register(O.type, O),
(O.prototype.getType = function() {
return O.type;
}),
(O.prototype.toJSON = function() {
var t = N.prototype.toJSON.call(this);
(t.v = []), (t.volType = this.volType);
for (var e = 0; e < this.v.length; ++e) t.v.push(this.v[e].toJSON());
return t;
}),
(O.prototype.mutableVolType = function() {
return !1;
}),
(O.prototype.setVolType = function(t) {
t !== this.volType && ((this.volType = t), this.invalidAABB());
}),
(O.prototype.getVolType = function() {
return this.volType;
}),
(O.prototype.computeAABB = function() {
this.aabb.makeEmpty();
for (var t = 0; t < this.v.length; t++) this.aabb.union(this.v[t].getAABB());
});
var E = O,
q = 0,
j = function(e, i) {
(this.pos = e.clone()),
(this.thickness = i),
(this.id = q++),
(this.prim = null),
(this.aabb = new t.Box3()),
(this.valid_aabb = !1);
};
(j.prototype.setPrimitive = function(t) {
null === this.prim && (this.prim = t);
}),
(j.prototype.toJSON = function() {
return {
position: {x: this.pos.x, y: this.pos.y, z: this.pos.z},
thickness: this.thickness
};
}),
(j.fromJSON = function(e) {
return new j(
new t.Vector3(e.position.x, e.position.y, e.position.z),
e.thickness
);
}),
(j.prototype.setPos = function(t) {
(this.valid_aabb = !1), this.pos.copy(t), this.prim.invalidAABB();
}),
(j.prototype.setThickness = function(t) {
(this.valid_aabb = !1), (this.thickness = t), this.prim.invalidAABB();
}),
(j.prototype.setAll = function(t, e) {
(this.valid_aabb = !1),
(this.pos = t),
(this.thickness = e),
this.prim.invalidAABB();
}),
(j.prototype.getPos = function() {
return this.pos;
}),
(j.prototype.getThickness = function() {
return this.thickness;
}),
(j.prototype.getAABB = function() {
return (
this.valid_aabb || (this.computeAABB(), (this.valid_aabb = !0)), this.aabb
);
}),
(j.prototype.computeAABB = function() {
var e = this.getPos(),
i = this.getThickness() * z.KS;
this.aabb.set(
new t.Vector3(e.x - i, e.y - i, e.z - i),
new t.Vector3(e.x + i, e.y + i, e.z + i)
);
}),
(j.prototype.equals = function(t) {
return this.pos.equals(t.pos) && this.thickness === t.thickness;
});
var R = j,
C = function() {};
(C.prototype.sphereIntersect = function(t) {
throw "Error : sphereIntersect is abstract, should have been overwritten";
}),
(C.prototype.contains = function(t) {
throw "Error : contains is abstract, should have been overwritten";
}),
(C.prototype.getAcc = function(t, e) {
throw "Error : getAcc is abstract, should have been overwritten";
}),
(C.prototype.getNiceAcc = function(t) {
throw "Error : getNiceAcc is abstract, should have been overwritten";
}),
(C.prototype.getCurrAcc = function(t) {
throw "Error : getCurrAcc is abstract, should have been overwritten";
}),
(C.prototype.getRawAcc = function(t) {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(C.prototype.getMinAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
}),
(C.prototype.getMinRawAcc = function() {
throw "Error : getRawAcc is abstract, should have been overwritten";
});
var I,
J = C,
K = {nice: 0.3, raw: 1, curr: 0.3},
G = K,
H = function(e, i, r) {
J.call(this),
(this.p = new t.Vector3(e.x, e.y, e.z)),
(this.r = i),
(this.accFactor = r || 1);
};
((H.prototype = Object.create(J.prototype)).constructor = H),
(H.prototype.sphereIntersect = ((I = new t.Vector3()),
function(t) {
I.subVectors(t.center, this.p);
var e = t.radius + this.radius;
return I.lengthSq() < e * e;
})),
(H.prototype.contains = (function() {
var e = new t.Vector3();
return function(t) {
return e.subVectors(t, this.p), e.lengthSq() < this.r * this.r;
};
})()),
(H.prototype.getAcc = function(t, e) {
return this.radius * e;
}),
(H.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice * this.accFactor);
}),
(H.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr * this.accFactor);
}),
(H.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw * this.accFactor);
}),
(H.prototype.getMinAcc = function() {
return G.curr * this.r * this.accFactor;
}),
(H.prototype.getMinRawAcc = function() {
return G.raw * this.r * this.accFactor;
}),
(H.prototype.getAxisProjectionMinStep = function(t, e) {
var i = 1e8,
r = e - this.p[t];
return (
r < -2 * this.r
? (i = Math.min(
  i,
  Math.max(Math.abs(r + this.r), G.curr * this.r * this.accFactor)
  ))
: r < 2 * this.r && (i = Math.min(i, G.curr * this.r * this.accFactor)),
i
);
});
var L = H,
U = function(e, i, r, s) {
E.call(this),
this.v.push(e),
this.v[0].setPrimitive(this),
(this.volType = E.DIST),
(this.density = r),
this.materials.push(s),
(this.v_to_p = new t.Vector3());
};
((U.prototype = Object.create(E.prototype)).constructor = U),
(U.type = "ScalisPoint"),
s.register(U.type, U),
(U.prototype.getType = function() {
return U.type;
}),
(U.prototype.toJSON = function() {
var t = E.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(U.fromJSON = function(t) {
var e = R.fromJSON(t.v[0]),
i = _.fromJSON(t.materials[0]);
return new U(e, t.volType, t.density, i);
}),
(U.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(U.prototype.getDensity = function() {
return this.density;
}),
(U.prototype.setMaterial = function(t) {
this.materials[0].copy(t), this.invalidAABB();
}),
(U.prototype.computeHelpVariables = function() {
this.computeAABB();
}),
(U.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(U.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new L(this.v[0].getPos(), z.KS * this.v[0].getThickness(), z.KIS),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(U.prototype.heuristicStepWithin = function() {
return this.v[0].getThickness() / 3;
}),
(U.prototype.value = function(t, e) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
var i = this.v[0].getThickness();
this.v_to_p.subVectors(t, this.v[0].getPos());
var r = this.v_to_p.lengthSq() / (i * i),
s = 1 - z.KIS2 * r;
if (s > 0) {
if (((e.v = this.density * s * s * s * z.Poly6NF0D), e.g)) {
var o =
(-this.density * z.KIS2 * 6 * this.v_to_p.length() * s * s * z.Poly6NF0D) /
(i * i);
e.g
.copy(this.v_to_p)
.normalize()
.multiplyScalar(o);
}
e.m && e.m.copy(this.materials[0]);
} else (e.v = 0), e.g && e.g.set(0, 0, 0), e.m && e.m.copy(_.defaultMaterial);
}),
(U.prototype.distanceTo = function(t) {
return t.distanceTo(this.v[0].getPos());
});
var W = U,
Z = function(e, i, r, s) {
J.call(this),
(this.p0 = new t.Vector3(e.x, e.y, e.z)),
(this.p1 = new t.Vector3(i.x, i.y, i.z)),
(this.thick0 = r),
(this.thick1 = s),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p0_to_p = this.vector),
(this.p0_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.thick0 - this.thick1),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Z.prototype = Object.create(J.prototype)).constructor = Z),
(Z.prototype.proj_computation = function(t) {
(this.p0_to_p = this.vector),
this.p0_to_p.subVectors(t, this.p0),
(this.p0_to_p_sqrnorm = this.p0_to_p.lengthSq()),
(this.x_p_2D = this.p0_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p0_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Z.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p0_to_p_sqrnorm) - t.radius < this.thick0 * z.KS;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p1),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.thick1 * z.KS
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
r = this.p_proj_x / this.length,
s = this.thick0 * (1 - r) + r * this.thick1,
o = t.radius + s * z.KS;
return i < o * o;
}),
(Z.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p0_to_p_sqrnorm < this.thick0 * this.thick0 * z.KS2;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p1),
this.vector.lengthSq() < this.thick1 * this.thick1 * z.KS2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
r = e * e + i * i,
s = this.p_proj_x / this.length,
o = this.thick0 * (1 - s) + s * this.thick1;
return r < o * o * z.KS2;
}),
(Z.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
r = t.radius * Math.sqrt(1 + i * i) * 0.5,
s = this.p_proj_x;
if ((s += this.thick0 > this.thick1 ? r : -r) < 0) return this.thick0 * e;
if (s > this.length) return this.thick1 * e;
var o = s / this.length;
return (this.thick0 * (1 - o) + o * this.thick1) * e;
}),
(Z.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(Z.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(Z.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(Z.prototype.getMinAcc = function() {
return G.curr * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getMinRawAcc = function() {
return G.raw * Math.min(this.thick0, this.thick1);
}),
(Z.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
r,
s,
o = Number.MAX_VALUE,
n = this.p0[t] < this.p1[t] ? this.p0 : this.p1;
n === this.p0
? ((i = this.p1), (r = this.thick0), (s = this.thick1))
: ((i = this.p0), (r = this.thick1), (s = this.thick0));
var h = e - n[t];
h < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), G.curr * r)))
: h < 2 * r && (o = Math.min(o, G.curr * r)),
(h = e - i[t]) < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), G.curr * s)))
: h < 2 * s && (o = Math.min(o, G.curr * s));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, G.curr * (r + (a / c) * (s - r)))),
o
);
});
var X,
Q,
Y,
$,
tt = Z,
et = function(e, i, r, s, o) {
E.call(this),
(this.v.length = 2),
(this.v[0] = e),
(this.v[1] = i),
e.setPrimitive(this),
i.setPrimitive(this),
(this.volType = r),
(this.density = s),
(this.materials = o),
(this.clipped_l1 = 1),
(this.clipped_l2 = 0),
(this.vector = new t.Vector3()),
(this.cycle = new t.Vector3()),
(this.proj = new t.Vector3()),
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
(this.dir = new t.Vector3()),
(this.lengthSq = 0),
(this.length = 0),
(this.unit_dir = new t.Vector3()),
(this.weight_p1 = 0),
(this.c0 = 0),
(this.c1 = 0),
(this.increase_unit_dir = new t.Vector3()),
(this.p_min = new t.Vector3()),
(this.weight_min = 0),
(this.inv_weight_min = 0),
(this.unit_delta_weight = 0),
(this.maxbound = 0),
(this.maxboundSq = 0),
(this.cyl_bd0 = 0),
(this.cyl_bd1 = 0),
(this.f0f1f2 = new t.Vector3()),
(this.tmpVec1 = new t.Vector3()),
(this.tmpVec2 = new t.Vector3()),
this.computeHelpVariables();
};
(et.prototype = Object.create(E.prototype)),
(et.constructor = et),
(et.type = "ScalisSegment"),
s.register(et.type, et),
(et.prototype.getType = function() {
return et.type;
}),
(et.prototype.toJSON = function() {
var t = E.prototype.toJSON.call(this);
return (t.density = this.density), t;
}),
(et.fromJSON = function(t) {
var e = R.fromJSON(t.v[0]),
i = R.fromJSON(t.v[1]),
r = [_.fromJSON(t.materials[1]), _.fromJSON(t.materials[1])];
return new et(e, i, t.volType, t.density, r);
}),
(et.prototype.mutableVolType = function() {
return !0;
}),
(et.prototype.setDensity = function(t) {
(this.density = t), this.invalidAABB();
}),
(et.prototype.getDensity = function() {
return this.density;
}),
(et.prototype.setVolType = function(t) {
if (t != E.CONVOL && t != E.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(et.prototype.getVolType = function() {
return this.volType;
}),
(et.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(et.prototype.getAreas = function() {
if (this.valid_aabb)
return [
{
aabb: this.aabb,
bv: new tt(
this.v[0].getPos(),
this.v[1].getPos(),
this.v[0].getThickness(),
this.v[1].getThickness(),
this.length,
this.unit_dir
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(et.prototype.computeHelpVariables = function() {
(this.v0_p = this.v[0].getPos()),
(this.v1_p = this.v[1].getPos()),
this.dir.subVectors(this.v1_p, this.v0_p),
(this.lengthSq = this.dir.lengthSq()),
(this.length = Math.sqrt(this.lengthSq)),
this.unit_dir.copy(this.dir).normalize(),
(this.weight_p1 = this.v[1].getThickness()),
(this.c0 = this.v[0].getThickness()),
(this.c1 = this.v[1].getThickness() - this.v[0].getThickness());
var t = this.v[0].getThickness() * z.KS,
e = this.v[1].getThickness() * z.KS;
(this.maxbound = Math.max(t, e)),
(this.maxboundSq = this.maxbound * this.maxbound),
(this.cyl_bd0 = Math.min(-t, this.length - e)),
(this.cyl_bd1 = Math.max(this.length + e, t)),
this.increase_unit_dir.copy(this.unit_dir),
this.c1 < 0
? (this.p_min.copy(this.v1_p),
  (this.weight_min = this.weight_p1),
  (this.inv_weight_min = 1 / this.weight_p1),
  this.increase_unit_dir.negate(),
  (this.unit_delta_weight = -this.c1 / this.length))
: (this.p_min.copy(this.v0_p),
  (this.weight_min = this.c0),
  (this.inv_weight_min = 1 / this.c0),
  (this.unit_delta_weight = this.c1 / this.length)),
this.computeAABB();
}),
(et.prototype.value = function(t, e) {
switch (this.volType) {
case E.DIST:
this.evalDist(t, e);
break;
case E.CONVOL:
this.evalConvol(t, e);
break;
default:
throw "Unknown volType, cannot evaluate.";
}
}),
(et.prototype.evalDist = ((X = {v: 0}),
(Q = new t.Vector3()),
function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var r = i.dot(this.dir),
s = i.lengthSq(),
o = this.lengthSq * this.c0 + r * this.c1,
n = this.c1 < 0 ? 0 : 1;
o > 0 && (n = (n = r * this.c0 + s * this.c1) < 0 ? 0 : n > o ? 1 : n / o);
var h = Math.sqrt(n * (n * this.lengthSq - 2 * r) + s),
a = this.c0 + n * this.c1;
if (
((e.v = this.density * z.Poly6Eval(h / a) * z.Poly6NF0D),
e.m && this.evalMat(t, e),
e.g)
) {
var c = this.density / 1e-5;
Q.copy(t),
(Q.x += 1e-5),
this.evalDist(Q, X),
(e.g.x = c * (X.v - e.v)),
(Q.x -= 1e-5),
(Q.y += 1e-5),
this.evalDist(Q, X),
(e.g.y = c * (X.v - e.v)),
(Q.y -= 1e-5),
(Q.z += 1e-5),
this.evalDist(Q, X),
(e.g.z = c * (X.v - e.v));
}
})),
(et.prototype.evalMat = function(t, e) {
var i = this.vector;
i.subVectors(t, this.v[0].getPos());
var r = this.unit_dir.dot(i) / this.length;
r > 1
? e.m.copy(this.materials[1])
: r <= 0
? e.m.copy(this.materials[0])
: (e.m.copy(this.materials[0]), e.m.lerp(this.materials[1], r));
}),
(et.prototype.HomotheticClippingSpecial = function(t) {
var e = -t.z,
i = -t.y,
r = -t.x,
s = i * i - e * r;
if (s >= 0) {
var o = i + Math.sqrt(s);
if (o < 0 || this.length * o < r) return !1;
var n = r / o;
this.clipped_l1 = n < 0 ? 0 : n;
var h = e * n;
return (
(this.clipped_l2 = 2 * i < h + e * this.length ? r / h : this.length), !0
);
}
return !1;
}),
(et.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(et.prototype.evalConvol = function(t, e) {
if (!this.valid_aabb) throw "Error : prepareForEval should have been called";
e.g && e.g.set(0, 0, 0), (e.v = 0);
var i = this.tmpVec1;
i.subVectors(t, this.p_min);
var r = this.increase_unit_dir.dot(i),
s = i.lengthSq(),
o = this.tmpVec2;
if (
(o.set(
this.weight_min * this.weight_min - z.KIS2 * s,
-this.unit_delta_weight * this.weight_min - z.KIS2 * r,
this.unit_delta_weight * this.unit_delta_weight - z.KIS2
),
this.HomotheticClippingSpecial(o))
) {
var n = 1 / (this.weight_min + this.clipped_l1 * this.unit_delta_weight);
(o.x = 1 - z.KIS2 * (this.clipped_l1 * (this.clipped_l1 - 2 * r) + s) * n * n),
(o.y = -this.unit_delta_weight - z.KIS2 * (r - this.clipped_l1) * n),
e.g
? (this.unit_delta_weight >= 0.06
  ? this.HomotheticCompactPolynomial_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    o
    )
  : this.HomotheticCompactPolynomial_approx_segment_FGradF_i6(
    (this.clipped_l2 - this.clipped_l1) * n,
    this.unit_delta_weight,
    this.inv_weight_min,
    o
    ),
  (e.v = z.Poly6NF1D * this.f0f1f2.x),
  (this.f0f1f2.y *= n),
  e.g
  .copy(this.increase_unit_dir)
  .multiplyScalar(this.f0f1f2.z + this.clipped_l1 * this.f0f1f2.y)
  .sub(i.multiplyScalar(this.f0f1f2.y))
  .multiplyScalar(6 * z.Poly6NF1D * z.KIS2 * n))
: this.unit_delta_weight >= 0.06
? (e.v =
  z.Poly6NF1D *
  this.HomotheticCompactPolynomial_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  o
  ))
: (e.v =
  z.Poly6NF1D *
  this.HomotheticCompactPolynomial_approx_segment_F_i6(
  (this.clipped_l2 - this.clipped_l1) * n,
  this.unit_delta_weight,
  n,
  o
  )),
e.m && this.evalMat(t, e);
}
}),
(et.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(et.prototype.distanceTo = ((Y = new t.Vector3()),
($ = new t.Vector3()),
function(t) {
var e = Y.subVectors(t, this.v[0].getPos()).dot(this.dir) / this.lengthSq;
return (
(e = this.clamp(e, 0, 1)),
$.copy(this.dir)
.multiplyScalar(e)
.add(this.v[0].getPos()),
t.distanceTo($)
);
})),
(et.prototype.HomotheticCompactPolynomial_segment_F_i6 = function(t, e, i) {
var r = e * t + 1,
s = 1 / r,
o = r * r,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 12 * a,
p = 1 / e,
l = h * p,
u = r * o,
v = t * t,
_ = v * v,
m = t * v,
g = t * _,
y = i.x,
d = i.z,
f = y * y,
b = d * d,
w = 1 / (u * u),
x = s * n,
V = 1 / u,
A = 1 / o;
return (
-b *
(((((-(s - 1) * p - t * A) * p - v * V) * p - m * n) * p - _ * x) * p - g * w) *
l +
((-y * (w - 1) * p) / 6 - ((-(x - 1) * p) / 5 - t * w) * l) * f +
(((y * c + 3 * d * f) * (0.4 * ((-(n - 1) * p) / 4 - t * x) * p - v * w) +
(3 * b * y + d * c) *
(0.8 *
(0.75 * ((2 / 3) * ((-(A - 1) * p) / 2 - t * V) * p - v * n) * p - m * x) *
p -
_ * w) +
d *
b *
(1.2 *
((5 / 4) *
((4 / 3) * (1.5 * (2 * (Math.log(r) * p - t * s) * p - v * A) * p - m * V) * p -
_ * n) *
p -
g * x) *
p -
m * m * w) +
(-12 * d * y - 8 * a) *
(0.6 * ((((-(V - 1) * p) / 3 - t * n) * p) / 2 - v * x) * p - m * w) *
h) *
p) /
6
);
}),
(et.prototype.HomotheticCompactPolynomial_approx_segment_F_i6 = function(
t,
e,
i,
r
) {
var s = i * e,
o = s + 1,
n = 1 / o,
h = o * o,
a = n / (h * h) / h,
c = r.z,
p = r.y,
l = r.x,
u = t * t,
v = c * u - 2 * p * t + l,
_ = c * l - p * p,
m = c * t - p,
g = l * l,
y = p * g,
d = v * v,
f = m * d,
b = 1 / c,
w = _ * b,
x =
(6 / 35) * ((4 / 3) * (2 * _ * t + m * v + p * l) * w + f + y) * w +
(v * f) / 7 +
(l * y) / 7,
V = b * x,
A = n * a,
S = d * d,
M = p * V + S / 8 - (g * g) / 8,
T = -t * S + (-10 * p * M + l * x) * b;
return (
V -
7 * e * M * b +
((-0.1111111111 * (3 * a - 3 + 7 * (2 + A) * s) * T -
((0.1 * (2 - 2 * a - 7 * (1 + A) * s)) / i) *
(-1 * u * S + (1.333333333 * p * T + 2 * l * M) * b)) *
b) /
(i * i)
);
}),
(et.prototype.HomotheticCompactPolynomial_segment_FGradF_i6 = function(
t,
e,
i
) {
var r = e * t + 1,
s = 1 / r,
o = r * r,
n = 1 / (o * o),
h = i.y,
a = h * h,
c = 2 * a,
p = i.z,
l = i.x,
u = (p * l) / 3 + (2 / 3) * a,
v = p * p,
_ = v / 6,
m = (-2 / 3) * p,
g = r * o,
y = 1 / g,
d = s * n,
f = 1 / (g * g),
b = t * t,
w = 1 / e,
x = t * b,
V = 0.6 * ((((-(y - 1) * w) / 3 - t * n) * w) / 2 - b * d) * w - x * f,
A = V * h,
S = (-(d - 1) * w) / 5 - t * f,
M = l * l,
T = M * S,
B = 0.4 * ((-(n - 1) * w) / 4 - t * d) * w - b * f,
P = l * B,
k = (-M * (f - 1)) / 6,
F = b * b,
N = t * F,
D = 1 / o,
z =
0.8 *
(0.75 * ((2 / 3) * ((-(D - 1) * w) / 2 - t * y) * w - b * n) * w - x * d) *
w -
F * f,
O =
((((-(s - 1) * w - t * D) * w - b * y) * w - x * n) * w - F * d) * w - N * f,
E = x * x,
q = Math.log(r);
(this.f0f1f2.x =
(l * k -
h * T +
P * c -
(4 / 3) * a * A +
((M * B) / 2 + z * c - 2 * l * A) * p +
((l * z) / 2 -
h * O +
((-E * f) / 6 +
((-N * d) / 5 +
((-F * n) / 4 + ((-x * y) / 3 + ((-b * D) / 2 + (q * w - t * s) * w) * w) * w) *
w) *
w) *
p) *
v) *
w),
(this.f0f1f2.y = (k + B * u + z * _ + ((-2 / 3) * l * S + V * m) * h) * w),
(this.f0f1f2.z = (T / 6 + V * u + O * _ + ((-2 / 3) * P + z * m) * h) * w);
}),
(et.prototype.HomotheticCompactPolynomial_approx_segment_FGradF_i6 = function(
t,
e,
i,
r
) {
var s = i * e,
o = s + 1,
n = 1 / o,
h = 1 / (i * i),
a = o * o,
c = n / (a * a) / a,
p = r.x,
l = 2 * p,
u = r.z,
v = 1 / u,
_ = e * v,
m = r.y,
g = t * t,
y = u * g - 2 * m * t + p,
d = y * y,
f = y * d,
b = p * p,
w = p * b,
x = u * p - m * m,
V = u * t - m,
A = x * v,
S = (4 / 3) * (2 * x * t + V * y + m * p) * A + V * d + m * b,
M = S / 5,
T = m * v * M + f / 6 - w / 6,
B = -t * f + (-8 * m * T + p * M) * v,
P = g * f,
k = ((10 / 7) * m * B + T * l) * v - P,
F = -k / 8,
N = (6 / 35) * S * A + (V * f) / 7 + (m * w) / 7,
D = n * c,
z = (3 * c - 3 + 7 * (2 + D) * s) * h,
O = ((2 - 2 * c - 7 * (1 + D) * s) / i) * h,
E = v * z,
q = v * O,
j = v * N,
R = d * d,
C = m * j + R / 8 - (b * b) / 8,
I = -t * R + (-10 * m * C + p * N) * v;
(this.f0f1f2.x =
j -
7 * C * _ -
(I * E) / 9 -
((-g * R + ((4 / 3) * m * I + C * l) * v) * q) / 10),
(this.f0f1f2.y = (M - 7 * e * T - (B * z) / 7 + O * F) * v),
(this.f0f1f2.z =
T * v +
B * _ +
E * F -
((-t * P + (1.5 * m * k - (3 / 7) * p * B) * v) * q) / 9);
});
var it = et,
rt = {},
st = function(t, e) {
var i = t;
if (0 === e) throw "Lenght of the array should not be null";
return 1 === e ? 0 : (t < 0 && (i = (e + t) % e), t >= e && (i = t % e), i);
};
(rt.computeVectorsDirs = function(e) {
var i = e.v[0].getPos(),
r = e.v[1].getPos(),
s = e.v[2].getPos();
e.p0p1.subVectors(r, i),
e.p1p2.subVectors(s, r),
e.p2p0.subVectors(i, s),
e.unit_normal.crossVectors(e.p0p1, e.p2p0),
e.unit_normal.normalize(),
(e.length_p0p1 = e.p0p1.length()),
e.unit_p0p1.copy(e.p0p1),
e.unit_p0p1.divideScalar(e.length_p0p1),
(e.diffThick_p0p1 = e.v[0].getThickness() - e.v[1].getThickness()),
(e.length_p1p2 = e.p1p2.length()),
e.unit_p1p2.copy(e.p1p2),
e.unit_p1p2.divideScalar(e.length_p1p2),
(e.diffThick_p1p2 = e.v[1].getThickness() - e.v[2].getThickness()),
(e.length_p2p0 = e.p2p0.length()),
e.unit_p2p0.copy(e.p2p0),
e.unit_p2p0.divideScalar(e.length_p2p0),
(e.diffThick_p2p0 = e.v[2].getThickness() - e.v[0].getThickness());
var o = [];
o.push({vert: e.v[0].getPos(), thick: e.v[0].getThickness(), idx: 0}),
o.push({vert: e.v[1].getPos(), thick: e.v[1].getThickness(), idx: 1}),
o.push({vert: e.v[2].getPos(), thick: e.v[2].getThickness(), idx: 2}),
o.sort(function(t, e) {
return t.thick - e.thick;
}),
(e.point_min = o[0].vert),
(e.weight_min = o[0].thick);
var n = st(o[0].idx + 1, 3),
h = e.v[n].getPos(),
a = e.v[n].getThickness();
n = st(o[0].idx + 2, 3);
var c = e.v[n].getPos(),
p = e.v[n].getThickness(),
l = new t.Vector3();
l = l.subVectors(h, e.point_min);
var u = new t.Vector3();
u = u.subVectors(c, e.point_min);
var v = a - e.weight_min,
_ = p - e.weight_min;
if (v < 1e-6 || _ < 1e-6) {
if (v < _) {
(e.ortho_dir = l.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(u) < 0 && e.main_dir.multiplyScalar(-1);
var m = -e.weight_min / _;
e.point_iso_zero = new t.Vector3(
e.point_min.x + m * u.x,
e.point_min.y + m * u.y,
e.point_min.z + m * u.z
);
} else {
(e.ortho_dir = u.clone()),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
e.main_dir.dot(l) < 0 && e.main_dir.multiplyScalar(-1);
m = -e.weight_min / v;
e.point_iso_zero = new t.Vector3(
e.point_min.x + m * l.x,
e.point_min.y + m * l.y,
e.point_min.z + m * l.z
);
}
Math.abs(v - _) < 1e-6 &&
((e.proj_dir = e.unit_normal.clone().multiplyScalar(-1)),
(e.equal_weights = !0));
} else {
var g = -e.weight_min / v,
y = new t.Vector3(
e.point_min.x + g * l.x,
e.point_min.y + g * l.y,
e.point_min.z + g * l.z
);
e.point_iso_zero = y;
var d = -e.weight_min / _,
f = new t.Vector3(
e.point_min.x + d * u.x,
e.point_min.y + d * u.y,
e.point_min.z + d * u.z
);
e.ortho_dir.subVectors(f, y),
e.ortho_dir.normalize(),
e.main_dir.crossVectors(e.ortho_dir, e.unit_normal),
e.main_dir.normalize(),
(e.main_dir.dot(l) < 0 || e.main_dir.dot(u) < 0) &&
e.main_dir.multiplyScalar(-1);
}
var b = l.dot(e.main_dir),
w = u.dot(e.main_dir),
x = null;
(b = b < 0 ? 0 : b) > (w = w < 0 ? 0 : w)
? ((x = l),
  (e.half_dir_1 = u),
  (e.point_half = c),
  (e.half_dir_2 = h.clone().subVectors(h, c)),
  (e.coord_max = b),
  (e.coord_middle = (w / b) * e.coord_max),
  (e.unit_delta_weight = v / e.coord_max))
: ((x = u),
  (e.half_dir_1 = l),
  (e.point_half = h),
  (e.half_dir_2 = c.clone().subVectors(c, h)),
  (e.coord_max = w),
  (e.coord_middle = (b / w) * e.coord_max),
  (e.unit_delta_weight = _ / e.coord_max)),
(e.longest_dir_special = x.divideScalar(e.coord_max));
var V = new t.Vector3();
V.subVectors(
e.half_dir_1,
e.longest_dir_special.clone().multiplyScalar(e.coord_middle)
),
(e.max_seg_length = V.length()),
(e.unsigned_ortho_dir = e.ortho_dir.clone()),
e.ortho_dir.dot(V) < 0 && e.ortho_dir.multiplyScalar(-1);
}),
(rt.getParametrisedVertexAttr = function(e, i, r) {
var s = rt.getMeanThick(e, i, r),
o = new t.Vector3(),
n = o.subVectors(e.v[1].getPos(), e.v[0].getPos()).multiplyScalar(i),
h = o
.clone()
.subVectors(e.v[2].getPos(), e.v[0].getPos())
.multiplyScalar(r);
return o.addVectors(e.v[0].getPos(), n), o.addVectors(o, h), {pos: o, thick: s};
}),
(rt.getMeanThick = function(t, e, i) {
return (
t.v[0].getThickness() * (1 - e - i) +
t.v[1].getThickness() * e +
t.v[2].getThickness() * i
);
}),
(rt.getMeanMat = function(t, e, i) {
var r = new Material(),
s =
null === t.materials
? [t.v[0].getMaterial(), t.v[0].getMaterial(), t.v[0].getMaterial()]
: [t.materials[0], t.materials[1], t.materials[2]];
return r.weightedMean(s, [1 - e - i, e, i]), r;
}),
(rt.getTriBaryCoord = function(e, i, r, s) {
var o = e,
n = i.clone().multiplyScalar(-1),
h = new t.Vector3().subVectors(s, r),
a = o.lengthSq(),
c = o.dot(n),
p = h.dot(o),
l = n.lengthSq(),
u = (a * h.dot(n) - c * p) / (a * l - c * c);
return {u: (p - u * c) / a, v: u};
}),
(rt.getUVCoord = function(e, i, r, s) {
var o = new t.Vector3();
o.crossVectors(e, i);
var n = new t.Matrix4();
n.set(e.x, i.x, o.x, 0, e.y, i.y, o.y, 0, e.z, i.z, o.z, 0, 0, 0, 0, 1);
var h = new t.Matrix4();
h.getInverse(n);
var a = new t.Vector3().subVectors(s, r);
return a.applyMatrix4(h), {u: a.x, v: a.y};
});
var ot = rt,
nt = function(e, i, r, s, o, n) {
J.call(this),
(this.tmpVect = new t.Vector3()),
(this.min_thick = o),
(this.max_thick = n),
(this.v = e),
(this.p0p1 = this.tmpVect
.clone()
.subVectors(this.v[1].getPos(), this.v[0].getPos())),
(this.p2p0 = this.tmpVect
.clone()
.subVectors(this.v[0].getPos(), this.v[2].getPos())),
(this.unit_normal = i),
(this.main_dir = r);
var h = Math.abs(this.v[0].getThickness() - this.v[1].getThickness()),
a = Math.abs(this.v[1].getThickness() - this.v[2].getThickness());
(this.equal_weights =
h / Math.abs(this.v[0].getThickness() + this.v[1].getThickness()) < 0.001 &&
a / Math.abs(this.v[1].getThickness() + this.v[2].getThickness()) < 0.001),
(this.segParams = s),
(this.segAttr = {
p0_to_p: 0,
p0_to_p_sqrnorm: 0,
x_p_2D: 0,
y_p_2D: 0,
y_p_2DSq: 0,
p_proj_x: 0
});
var c = this.tmpVect
.clone()
.crossVectors(this.segParams[0].dir, this.unit_normal)
.normalize(),
p = this.tmpVect
.clone()
.crossVectors(this.segParams[1].dir, this.unit_normal)
.normalize(),
l = this.tmpVect
.clone()
.crossVectors(this.segParams[2].dir, this.unit_normal)
.normalize();
this.tmpVect.copy(this.unit_normal);
var u = [];
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(this.v[0].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(this.v[1].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(this.v[2].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[0].getPos(),
this.tmpVect.multiplyScalar(-this.v[0].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[1].getPos(),
this.tmpVect.multiplyScalar(-this.v[1].getThickness() * z.KS)
)
),
this.tmpVect.copy(this.unit_normal),
u.push(
this.tmpVect
.clone()
.addVectors(
this.v[2].getPos(),
this.tmpVect.multiplyScalar(-this.v[2].getThickness() * z.KS)
)
);
var v = new t.Vector3();
this.tmpVect.subVectors(u[1], u[0]), v.subVectors(u[2], u[0]);
var _ = this.tmpVect
.clone()
.crossVectors(this.tmpVect, v)
.normalize();
this.tmpVect.subVectors(u[5], u[3]), v.subVectors(u[4], u[3]);
var m = this.tmpVect
.clone()
.crossVectors(this.tmpVect, v)
.normalize();
(this.planeParams = []),
this.planeParams.push({orig: this.v[0].getPos(), n: c}),
this.planeParams.push({orig: this.v[1].getPos(), n: p}),
this.planeParams.push({orig: this.v[2].getPos(), n: l}),
this.planeParams.push({orig: u[0], n: _}),
this.planeParams.push({orig: u[3], n: m}),
(this.segAreas = []);
for (var g = 0; g < 3; ++g)
this.segAreas.push(
new tt(
this.segParams[g].v[0].getPos(),
this.segParams[g].v[1].getPos(),
this.segParams[g].v[0].getThickness(),
this.segParams[g].v[1].getThickness(),
this.segParams[g].norm,
this.segParams[g].dir
)
);
};
((nt.prototype = Object.create(J.prototype)).constructor = nt),
(nt.prototype.proj_computation = function(t, e) {
(this.segAttr.p0_to_p = this.tmpVect),
this.segAttr.p0_to_p.subVectors(t, e.v[0].getPos()),
(this.segAttr.p0_to_p_sqrnorm = this.segAttr.p0_to_p.lengthSq()),
(this.segAttr.x_p_2D = this.segAttr.p0_to_p.dot(e.dir)),
(this.segAttr.y_p_2DSq =
this.segAttr.p0_to_p_sqrnorm - this.segAttr.x_p_2D * this.segAttr.x_p_2D),
(this.segAttr.y_p_2D =
this.segAttr.y_p_2DSq > 0 ? Math.sqrt(this.segAttr.y_p_2DSq) : 0);
var i = -this.segAttr.y_p_2D / e.ortho_vec_y;
this.segAttr.p_proj_x = this.segAttr.x_p_2D + i * e.ortho_vec_x;
}),
(nt.prototype.sphereIntersect = function(t) {
for (var e = 0; e < 3; e++) {
if (this.sphereIntersectSegment(t, this.segParams[e], z.KS)) return !0;
}
e = 0;
for (var i = !0; e < 5; e++) {
this.tmpVect.subVectors(t.center, this.planeParams[e].orig);
var r = this.tmpVect.dot(this.planeParams[e].n);
i = i && r + t.r > 0;
}
return i;
}),
(nt.prototype.sphereIntersectSegment = function(t, e, i) {
this.proj_computation(t.center, e);
var r = e.v[0].getThickness(),
s = e.v[1].getThickness();
if (this.segAttr.p_proj_x < 0)
return Math.sqrt(this.segAttr.p0_to_p_sqrnorm) - t.r < r * i;
if (this.segAttr.p_proj_x > e.norm)
return (
this.segAttr.p0_to_p.subVectors(t.center, e.v[1].getPos()),
this.segAttr.p0_to_p.length() - t.r < s * i
);
var o = this.segAttr.x_p_2D - this.segAttr.p_proj_x,
n = o * o + this.segAttr.y_p_2DSq,
h = this.segAttr.p_proj_x / e.norm,
a = r * (1 - h) + h * s,
c = t.r + a * i;
return n < c * c;
}),
(nt.prototype.contains = function(t) {
var e = {r: 0, c: t};
return this.sphereIntersect(e);
}),
(nt.prototype.getAccSegment = function(t, e) {
var i = {intersect: !1, currAcc: G.nice * this.min_thick};
if (this.sphereIntersectSegment(t, e, 1)) {
var r = Math.abs(e.diffThick) / e.norm,
s = t.r * Math.sqrt(1 + r * r) * 0.5,
o = e.v[0].getThickness(),
n = e.v[1].getThickness(),
h = this.segAttr.p_proj_x;
if ((h += o > n ? s : -s) <= 0) i.currAcc = o;
else if (h >= e.norm) i.currAcc = n;
else {
var a = h / e.norm;
i.currAcc = o * (1 - a) + a * n;
}
i.intersect = !0;
}
return i;
}),
(nt.prototype.getAccTri = function(t) {
if (this.equal_weights) return this.min_thick;
var e = this.v[0].getPos(),
i = this.tmpVect.addVectors(
t.center,
this.main_dir.clone().multiplyScalar(t.r)
);
this.tmpVect.subVectors(i, e);
var r = this.tmpVect.lengthSq(),
s = this.tmpVect.dot(this.unit_normal),
o = Math.sqrt(r - s * s),
n = this.tmpVect
.clone()
.addVectors(t.center, this.unit_normal.clone().multiplyScalar(-s)),
h = ot.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), n),
a = ot.getMeanThick(this, h.u, h.v);
a = s >= 0 ? a : -a;
var c = o + (-s / o) * (this.v[0].getThickness() - a),
p = this.tmpVect.subVectors(e, n).normalize(),
l = this.tmpVect.addVectors(n, p.multiplyScalar(o - c));
return (h = ot.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), l))
.u <= 1 &&
h.v <= 1 &&
h.u + h.v <= 1 &&
h.u >= 0 &&
h.v >= 0
? ot.getMeanThick(this, h.u, h.v)
: 1e4 * this.max_thick;
}),
(nt.prototype.getAcc = function(t, e) {
for (var i = 0, r = 1e5 * this.max_thick; i < 3; i++) {
var s = this.getAccSegment(t, this.segParams[i]);
s.intersect && (r = r > s.currAcc ? s.currAcc : r);
}
var o = 1e5 * this.max_thick;
r !== this.min_thick && (o = this.getAccTri(t));
var n = Math.min(r, o);
return n !== 1e5 * this.max_thick ? n * e : this.max_thick * e;
}),
(nt.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(nt.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(nt.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(nt.prototype.getMinAcc = function() {
return G.curr * this.min_thick;
}),
(nt.prototype.getMinRawAcc = function() {
return G.raw * this.min_thick;
}),
(nt.prototype.getAxisProjectionMinStep = function(t, e) {
for (var i = Number.MAX_VALUE, r = 0; r < 3; ++r)
i = Math.min(i, this.segAreas[r].getAxisProjectionMinStep(t, e));
return i;
});
var ht,
at,
ct,
pt,
lt,
ut,
vt = nt,
_t = function(e, i, r, s) {
if ((E.call(this), 1 !== r))
throw "Error in ScalisTriangle : cannot use a density different from 1.0, not implemented.";
(this.volType = i),
(this.materials =
null !== s
? s
: [
  _.defaultMaterial.clone(),
  _.defaultMaterial.clone(),
  _.defaultMaterial.clone()
  ]),
(this.v = e),
this.v[0].setPrimitive(this),
this.v[1].setPrimitive(this),
this.v[2].setPrimitive(this),
(this.min_thick = Math.min(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.max_thick = Math.max(
this.v[0].getThickness(),
this.v[1].getThickness(),
this.v[2].getThickness()
)),
(this.res_gseg = {}),
(this.tmp_res_gseg = {}),
(this.p0p1 = new t.Vector3()),
(this.p1p2 = new t.Vector3()),
(this.p2p0 = new t.Vector3()),
(this.unit_normal = new t.Vector3()),
(this.unit_p0p1 = new t.Vector3()),
(this.unit_p1p2 = new t.Vector3()),
(this.unit_p2p0 = new t.Vector3()),
(this.length_p0p1 = 0),
(this.length_p1p2 = 0),
(this.length_p2p0 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.diffThick_p0p1 = 0),
(this.main_dir = new t.Vector3()),
(this.point_iso_zero = new t.Vector3()),
(this.ortho_dir = new t.Vector3()),
(this.unsigned_ortho_dir = new t.Vector3()),
(this.proj_dir = new t.Vector3()),
(this.equal_weights = !1),
(this.coord_max = 0),
(this.coord_middle = 0),
(this.unit_delta_weight = 0),
(this.longest_dir_special = 0),
(this.max_seg_length = 0),
(this.half_dir_1 = new t.Vector3()),
(this.point_half = new t.Vector3()),
(this.half_dir_2 = new t.Vector3()),
(this.point_min = new t.Vector3()),
(this.weight_min = 0),
(this.valid_aabb = !1);
};
((_t.prototype = Object.create(E.prototype)).constructor = _t),
(_t.type = "ScalisTriangle"),
s.register(_t.type, _t),
(_t.prototype.getType = function() {
return _t.type;
}),
(_t.prototype.toJSON = function() {
return E.prototype.toJSON.call(this);
}),
(_t.fromJSON = function(t) {
var e = [R.fromJSON(t.v[0]), R.fromJSON(t.v[1]), R.fromJSON(t.v[2])],
i = [
_.fromJSON(t.materials[0]),
_.fromJSON(t.materials[1]),
_.fromJSON(t.materials[2])
];
return new _t(e, t.volType, i);
}),
(_t.prototype.prepareForEval = function() {
this.valid_aabb || (this.computeHelpVariables(), (this.valid_aabb = !0));
}),
(_t.prototype.getAreas = function() {
if (this.valid_aabb) {
var t = [];
return (
t.push({
norm: this.length_p0p1,
diffThick: this.diffThick_p0p1,
dir: this.unit_p0p1,
v: [this.v[0], this.v[1]],
ortho_vec_x: this.v[0].getThickness() - this.v[1].getThickness(),
ortho_vec_y: this.length_p0p1
}),
t.push({
norm: this.length_p1p2,
diffThick: this.diffThick_p1p2,
dir: this.unit_p1p2,
v: [this.v[1], this.v[2]],
ortho_vec_x: this.v[1].getThickness() - this.v[2].getThickness(),
ortho_vec_y: this.length_p1p2
}),
t.push({
norm: this.length_p2p0,
diffThick: this.diffThick_p2p0,
dir: this.unit_p2p0,
v: [this.v[2], this.v[0]],
ortho_vec_x: this.v[2].getThickness() - this.v[0].getThickness(),
ortho_vec_y: this.length_p2p0
}),
[
{
aabb: this.aabb,
bv: new vt(
this.v,
this.unit_normal,
this.main_dir,
t,
this.min_thick,
this.max_thick
),
obj: this
}
]
);
}
return console.log("ERROR : Cannot get area of invalid primitive"), [];
}),
(_t.prototype.computeHelpVariables = function() {
ot.computeVectorsDirs(this), this.computeAABB();
}),
(_t.prototype.mutableVolType = function() {
return !0;
}),
(_t.prototype.setVolType = function(t) {
if (t != E.CONVOL && t != E.DIST)
throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
this.volType != t && ((this.volType = t), this.invalidAABB());
}),
(_t.prototype.getVolType = function() {
return this.volType;
}),
(_t.prototype.clamp = function(t, e, i) {
return Math.max(e, Math.min(i, t));
}),
(_t.prototype.distanceTo = (function() {
var e = new t.Vector3(),
i = new t.Vector3(),
r = new t.Vector3(),
s = new t.Vector3();
return function(t) {
if (
(e.subVectors(t, this.v[0].getPos()),
i.subVectors(t, this.v[1].getPos()),
r.subVectors(t, this.v[2].getPos()),
s.crossVectors(this.p0p1, e).dot(this.unit_normal) > 0 &&
s.crossVectors(this.p1p2, i).dot(this.unit_normal) > 0 &&
s.crossVectors(this.p2p0, r).dot(this.unit_normal) > 0)
)
return Math.abs(e.dot(this.unit_normal));
var o = e.dot(this.p0p1) / this.length_p0p1;
(o = this.clamp(o, 0, 1)),
s
.copy(this.p0p1)
.multiplyScalar(o)
.add(this.v[0].getPos()),
(o = t.distanceToSquared(s));
var n = i.dot(this.p1p2) / this.length_p1p2;
(n = this.clamp(n, 0, 1)),
s
.copy(this.p1p2)
.multiplyScalar(n)
.add(this.v[1].getPos()),
(n = t.distanceToSquared(s));
var h = r.dot(this.p2p0) / this.length_p2p0;
return (
(h = this.clamp(h, 0, 1)),
s
.copy(this.p2p0)
.multiplyScalar(h)
.add(this.v[2].getPos()),
(h = t.distanceToSquared(s)),
Math.sqrt(Math.min(Math.min(o, n), h))
);
};
})()),
(_t.prototype.heuristicStepWithin = function() {
return this.weight_min / 3;
}),
(_t.prototype.value = function(t, e) {
switch (this.volType) {
case E.DIST:
return this.evalDist(t, e);
case E.CONVOL:
return this.evalConvol(t, e);
default:
throw "Unknown volType, use Orga";
}
}),
(_t.prototype.evalDist = (function() {
var e = {v: 0},
i = new t.Vector3();
return function(r, s) {
var o = new t.Vector3();
o.subVectors(r, this.v[0].getPos());
var n = this.unit_normal.clone().multiplyScalar(-1);
if (!this.equal_weights) {
var h = n,
a = this.unsigned_ortho_dir,
c = this.main_dir.clone().multiplyScalar(-1),
p = -this.v[0].getPos().dot(h),
l = -r.dot(a),
u = -this.point_iso_zero.dot(c),
v = new t.Vector3();
v.crossVectors(a, c), v.multiplyScalar(-p);
var _ = new t.Vector3();
_.crossVectors(c, h), _.multiplyScalar(-l);
var m = new t.Vector3();
m.crossVectors(h, a), m.multiplyScalar(-u);
var g = new t.Vector3();
g.crossVectors(a, c);
var y = new t.Vector3(v.x + _.x + m.x, v.y + _.y + m.y, v.z + _.z + m.z);
y.divideScalar(h.dot(g));
var d = new t.Vector3(y.x - r.x, y.y - r.y, y.z - r.z);
(this.proj_dir = new t.Vector3()),
this.proj_dir.crossVectors(d, this.unsigned_ortho_dir),
this.proj_dir.normalize();
}
var f = new t.Vector3();
f.copy(this.proj_dir),
f.multiplyScalar(-o.dot(n) / this.proj_dir.dot(n)),
f.add(r);
var b = new t.Vector3(),
w = new t.Vector3(),
x = new t.Vector3(),
V = new t.Vector3();
if (
(w.subVectors(f, this.v[0].getPos()),
x.subVectors(f, this.v[1].getPos()),
V.subVectors(f, this.v[2].getPos()),
b.crossVectors(this.unit_p0p1, w).dot(n) > 0 &&
b.crossVectors(this.unit_p1p2, x).dot(n) > 0 &&
b.crossVectors(this.unit_p2p0, V).dot(n) > 0)
) {
b.subVectors(r, f), (s.v = b.lengthSq());
var A = this.v[0].getPos(),
S = this.v[1].getPos(),
M = this.v[2].getPos(),
T = new t.Vector3();
b.subVectors(S, A), T.subVectors(M, A);
var B = new t.Vector3();
B.crossVectors(b, T),
b.subVectors(M, S),
(h = new t.Vector3()).crossVectors(b, x),
b.subVectors(A, M),
(a = new t.Vector3()).crossVectors(b, V),
b.subVectors(S, A),
(c = new t.Vector3()).crossVectors(b, w);
var P = B.lengthSq(),
k = B.dot(h),
F = B.dot(a),
N = B.dot(c),
D =
(k * this.v[0].getThickness() +
F * this.v[1].getThickness() +
N * this.v[2].getThickness()) /
P;
(s.v = z.Poly6Eval(Math.sqrt(s.v) / D) * z.Poly6NF0D),
s.m &&
s.m.triMean(
this.materials[0],
this.materials[1],
this.materials[2],
k,
F,
N,
P
);
} else {
var O = 0;
if (
(this.GenericSegmentComputation(
r,
this.v[0].getPos(),
this.p0p1,
this.length_p0p1,
this.length_p0p1 * this.length_p0p1,
this.v[0].getThickness(),
this.v[1].getThickness() - this.v[0].getThickness(),
this.res_gseg
),
(this.res_gseg.sqrdist = this.res_gseg.proj_to_p.lengthSq()),
(this.res_gseg.ratio =
this.res_gseg.sqrdist /
(this.res_gseg.weight_proj * this.res_gseg.weight_proj)),
this.GenericSegmentComputation(
r,
this.v[1].getPos(),
this.p1p2,
this.length_p1p2,
this.length_p1p2 * this.length_p1p2,
this.v[1].getThickness(),
this.v[2].getThickness() - this.v[1].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(O = 1)),
this.GenericSegmentComputation(
r,
this.v[2].getPos(),
this.p2p0,
this.length_p2p0,
this.length_p2p0 * this.length_p2p0,
this.v[2].getThickness(),
this.v[0].getThickness() - this.v[2].getThickness(),
this.tmp_res_gseg
),
(this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq()),
(this.tmp_res_gseg.ratio =
this.tmp_res_gseg.sqrdist /
(this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj)),
this.res_gseg.ratio > this.tmp_res_gseg.ratio &&
((this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist),
(this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p),
(this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj),
(this.res_gseg.ratio = this.tmp_res_gseg.ratio),
(this.res_gseg.t = this.tmp_res_gseg.t),
(O = 2)),
(s.v =
z.Poly6Eval(Math.sqrt(this.res_gseg.sqrdist) / this.res_gseg.weight_proj) *
z.Poly6NF0D),
s.m)
)
switch (O) {
case 0:
s.m.copy(this.materials[0]), s.m.lerp(this.materials[1], this.res_gseg.t);
break;
case 1:
s.m.copy(this.materials[1]), s.m.lerp(this.materials[2], this.res_gseg.t);
break;
case 2:
s.m.copy(this.materials[2]), s.m.lerp(this.materials[0], this.res_gseg.t);
break;
default:
throw "Error : seg_case unknown";
}
}
if (s.g) {
i.copy(r),
(i.x += 1e-5),
this.evalDist(i, e),
(s.g.x = (e.v - s.v) / 1e-5),
(i.x -= 1e-5),
(i.y += 1e-5),
this.evalDist(i, e),
(s.g.y = (e.v - s.v) / 1e-5),
(i.y -= 1e-5),
(i.z += 1e-5),
this.evalDist(i, e),
(s.g.z = (e.v - s.v) / 1e-5);
}
};
})()),
(_t.prototype.GenericSegmentComputation = function(e, i, r, s, o, n, h, a) {
var c = new t.Vector3();
c.subVectors(e, i);
var p = c.dot(r),
l = c.lengthSq(),
u = o * n + p * h,
v = h < 0 ? 0 : 1;
return (
u > 0 && (v = (v = (p * n + l * h) / u) < 0 ? 0 : v > 1 ? 1 : v),
(a.proj_to_p = new t.Vector3(v * r.x - c.x, v * r.y - c.y, v * r.z - c.z)),
(a.weight_proj = n + v * h),
(a.t = v),
a
);
}),
(_t.prototype.evalConvol = ((ht = new t.Vector3()),
(at = new _()),
(ct = {v: 0, g: null, m: null}),
(pt = new t.Vector3()),
(lt = new _()),
(ut = {v: 0, g: null, m: null}),
function(e, i) {
(ct.g = i.g ? ht : null), (ct.m = i.m ? at : null);
var r = {l1: 0, l2: 0};
if (this.ComputeTParam(e, r)) {
var s = r.l1,
o = r.l2,
n = this.weight_min + s * this.unit_delta_weight,
h = this.warpAbscissa((o - s) / n),
a = 2 * (5 * h + 1),
c = h / a,
p = c;
c *= 2;
for (var l = 0, u = new t.Vector3(), v = 1; v < a; v += 2)
this.computeLineIntegral(this.unwarpAbscissa(p) * n + s, e, ct),
(l += ct.v),
i.g && u.addVectors(u, ct.g),
(p += c);
var _ = 0,
m = new t.Vector3();
for (p = 0, v = 2; v < a; v += 2)
(p += c),
this.computeLineIntegral(this.unwarpAbscissa(p) * n + s, e, ct),
i.g && m.addVectors(m, ct.g),
(_ += ct.v);
(ut.g = i.g ? pt : null), (ut.m = i.m ? lt : null);
var g = this.computeLineIntegral(s, e, ct),
y = this.computeLineIntegral(o, e, ut);
i.v = g.v + 4 * l + 2 * _ + g.v;
var d = (h / (3 * a)) * z.Poly6NF2D;
if (((i.v *= d), i.g)) {
var f = new t.Vector3();
f.addVectors(f, g.g),
f.addVectors(f, u.multiplyScalar(4)),
f.addVectors(f, m.multiplyScalar(2)),
f.addVectors(f, y.g),
(i.g = f.multiplyScalar(d));
}
} else (i.v = 0), (i.g = new t.Vector3());
i.m && ((ct.g = null), this.evalDist(e, ct), i.m.copy(ct.m));
})),
(_t.prototype.warpAbscissa = function(t) {
var e = t * this.unit_delta_weight,
i = 1 / (e + 2),
r = e * i;
return (
2 *
t *
i *
(1 +
(r *= r) *
(1 / 3 + r * (0.2 + r * (1 / 7 + r * (1 / 9 + r * (1 / 11 + r * (1 / 13)))))))
);
}),
(_t.prototype.unwarpAbscissa = function(t) {
var e = t * this.unit_delta_weight;
return (
t * (1 + e * (0.5 + e * (1 / 6 + e * (1 / 24 + e * (1 / 120 + (1 * e) / 720)))))
);
}),
(_t.prototype.computeLineIntegral = function(e, i, r) {
var s = this.weight_min + e * this.unit_delta_weight,
o = new t.Vector3();
o.addVectors(
this.point_min,
this.longest_dir_special.clone().multiplyScalar(e)
);
var n =
e < this.coord_middle
? (e / this.coord_middle) * this.max_seg_length
: ((this.coord_max - e) / (this.coord_max - this.coord_middle)) *
  this.max_seg_length;
return (
r.g
? this.consWeightEvalGradForSeg(o, s, this.ortho_dir, n, i, r)
: this.consWeightEvalForSeg(o, s, this.ortho_dir, n, i, r),
r
);
}),
(_t.prototype.homotheticClippingSpecial = function(t, e, i) {
var r = -t.z,
s = -t.y,
o = -t.x,
n = s * s - r * o;
if (n >= 0) {
var h = s + Math.sqrt(n);
if (h < 0 || e * h < o) return !1;
var a = o / h;
i.l1 = a < 0 ? 0 : a;
var c = r * a;
return (i.l2 = 2 * s < c + r * e ? o / c : e), !0;
}
return !1;
}),
(_t.prototype.consWeightEvalForSeg = function(e, i, r, s, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = r.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - z.KIS2 * c, -z.KIS2 * a, -z.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, s, l)) {
var u = 1 / i;
(p.x = 1 - z.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -z.KIS2 * (a - l.l1) * u),
(n.v = this.homotheticCompactPolynomial_segment_F_i6_cste(
(l.l2 - l.l1) * u,
p
));
} else n = 0;
return n;
}),
(_t.prototype.consWeightEvalGradForSeg = function(e, i, r, s, o, n) {
var h = new t.Vector3();
h.subVectors(o, e);
var a = r.dot(h),
c = h.lengthSq(),
p = new t.Vector3();
p.set(i * i - z.KIS2 * c, -z.KIS2 * a, -z.KIS2);
var l = {l1: 0, l2: 0};
if (this.homotheticClippingSpecial(p, s, l)) {
var u = 1 / i;
(p.x = 1 - z.KIS2 * (l.l1 * (l.l1 - 2 * a) + c) * u * u),
(p.y = -z.KIS2 * (a - l.l1) * u);
var v = new t.Vector3();
this.homotheticCompactPolynomial_segment_FGradF_i6_cste(
(l.l2 - l.l1) * u,
p,
v
),
(n.v = v.x),
(v.y *= u);
var _ = r.clone();
_.multiplyScalar(v.z + l.l1 * v.y),
h.multiplyScalar(-v.y),
h.addVectors(h, _),
(n.g = h.multiplyScalar(6 * z.KIS2 * u));
} else (n.v = 0), n.g.set(0, 0, 0);
return n;
}),
(_t.prototype.ComputeTParam = function(e, i) {
var r = new t.Vector3();
r.subVectors(e, this.point_min);
var s = r.dot(this.main_dir),
o = r.dot(this.unit_normal),
n = s * s + o * o,
h = new t.Vector3();
return (
h.set(
this.weight_min * this.weight_min - z.KIS2 * n,
-this.unit_delta_weight * this.weight_min - z.KIS2 * s,
this.unit_delta_weight * this.unit_delta_weight - z.KIS2
),
this.homotheticClippingSpecial(h, this.coord_max, i)
);
}),
(_t.prototype.homotheticCompactPolynomial_segment_F_i6_cste = function(t, e) {
var i = e.z,
r = i * t,
s = e.y,
o = e.x,
n = i * o - s * s,
h = 1 / i,
a = n * h,
c = o + (-2 * s + r) * t,
p = r - s,
l = p * (c * c),
u = s * (o * o);
return (
((1.2 * ((4 / 3) * (2 * n * t + p * c + s * o) * a + l + u) * a +
c * l +
o * u) *
h) /
7
);
}),
(_t.prototype.homotheticCompactPolynomial_segment_FGradF_i6_cste = function(
t,
e,
i
) {
var r = e.z,
s = r * t,
o = e.y,
n = e.x,
h = r * n - o * o,
a = 1 / r,
c = h * a,
p = n + (-2 * o + s) * t,
l = s - o,
u = p * p,
v = n * n,
_ = (4 / 3) * (2 * h * t + l * p + o * n) * c + l * u + o * v,
m = (_ * a) / 5,
g = n * v,
y = p * u;
(i.x = ((1.2 * _ * c + l * y + o * g) * a) / 7),
(i.y = m),
(i.z = (o * m + y / 6 - g / 6) * a);
});
var mt = _t,
gt = function() {};
(gt.prototype.constructor = gt),
(gt.type = "DistanceFunctor"),
s.register(gt.type, gt),
(gt.prototype.getType = function() {
return gt.type;
}),
(gt.prototype.toJSON = function() {
return {type: this.getType()};
}),
(gt.prototype.fromJSON = function(t) {
return s.fromJSON(t);
}),
(gt.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(gt.prototype.value = function(t) {
throw "Error : not implemented. Must be reimplemented in children classes.";
}),
(gt.prototype.numericalGradient = function(t, e) {
var i = e || 1e-5;
return (this.value(t + i) - this.value(t - i)) / (2 * i);
}),
(gt.prototype.gradient = function(t) {
return this.numericalGradient(t, 1e-5);
}),
(gt.prototype.getSupport = function(t) {
return 1 / 0;
});
var yt = gt,
dt = function(t) {
this.scale = t || 1;
};
((dt.prototype = Object.create(yt.prototype)).constructor = dt),
(dt.type = "Poly6DistanceFunctor"),
s.register(dt.type, dt),
(dt.prototype.getType = function() {
return dt.type;
}),
(dt.prototype.toJSON = function() {
var t = Blobtree.DistanceFunctor.prototype.toJSON.call(this, c);
return (t.scale = this.scale), t;
}),
(dt.evalStandard = function(t) {
if (t < 0) return 1;
var e = 1 - t * t;
return e > 0 ? e * e * e : 0;
}),
(dt.prototype.value = function(t) {
var e = t / (2 * this.scale);
return dt.evalStandard((e += 0.5)) / dt.evalStandard(0.5);
}),
(dt.prototype.gradient = function(t) {
var e = t / (2 * this.scale) + 0.5,
i = 1 - e * e;
return (i = ((-6 / (2 * this.scale)) * e * i * i) / dt.evalStandard(0.5));
}),
(dt.prototype.getSupport = function(t) {
return this.scale;
});
var ft = dt,
bt = function() {
p.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((bt.prototype = Object.create(p.prototype)).constructor = bt),
(bt.type = "SDFNode"),
s.register(bt.type, bt),
(bt.prototype.getType = function() {
return bt.type;
}),
(bt.prototype.computeAABB = function() {}),
(bt.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFNode. Please reimplement it in children classes.";
}),
(bt.prototype.getAreas = function() {
throw "No Areas for SDFNode, except for the SDFRootNode.";
}),
(bt.prototype.distanceTo = function(t) {
throw "distanceTo should be reimplemented in every children classes of SDFNode.";
}),
(bt.prototype.heuristicStepWithin = function() {
throw "heuristicStepWithin may not make sens for all SDFNode, except for the SDFRootNode.";
});
var wt = bt,
xt = function(e, i, r) {
wt.call(this),
(this.f = e),
(this.material = i ? i.clone() : new _()),
this.addChild(r),
(this.tmp_res = {v: 0, g: null}),
(this.tmp_g = new t.Vector3(0, 0, 0));
};
((xt.prototype = Object.create(wt.prototype)).constructor = xt),
(xt.type = "SDFRootNode"),
s.register(xt.type, xt),
(xt.prototype.getType = function() {
return xt.type;
}),
(xt.prototype.addChild = function(t) {
if (0 !== this.children.length)
throw "Error : SDFRootNode can have only one child.";
wt.prototype.addChild.call(this, t);
}),
(xt.prototype.toJSON = function() {
var t = wt.prototype.toJSON.call(this);
return (t.f = this.f.toJSON()), t;
}),
(xt.fromJSON = function(t) {
var e = new xt(s.fromJSON(e.f), s.fromJSON(t.children[0]));
return e;
}),
(xt.prototype.prepareForEval = function() {
if (!this.valid_aabb) {
this.aabb = new t.Box3();
for (var e = 0; e < this.children.length; ++e) {
var i = this.children[e];
i.prepareForEval(), this.aabb.union(i.computeDistanceAABB(this.f.getSupport()));
}
this.valid_aabb = !0;
}
}),
(xt.prototype.getAreas = function() {
if (this.valid_aabb) return this.children[0].getAreas(this.f.getSupport());
throw "ERROR : Cannot get area of invalid node";
}),
(xt.prototype.value = function(t, e) {
var i = this.tmp_res;
(i.g = e.g ? this.tmp_g : null),
(e.v = 0),
e.m && e.m.copy(_.defaultMaterial),
e.g || (e.step && (e.step = 1e9)),
this.aabb.containsPoint(t)
? (this.children[0].value(t, i),
  (e.v = this.f.value(i.v)),
  e.g && e.g.copy(i.g).multiplyScalar(this.f.gradient(e.v)),
  e.m && e.m.copy(this.material))
: e.step && (e.step = this.aabb.distanceToPoint(t) + 0.3);
});
var Vt,
At = xt,
St = function() {
h.call(this),
this.aabb.set(
new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0),
new THREE.Vector3(1 / 0, 1 / 0, 1 / 0)
);
};
((St.prototype = Object.create(h.prototype)).constructor = St),
(St.type = "SDFPrimitive"),
s.register(St.type, St),
(St.prototype.SDFPrimitive = function() {
return St.type;
}),
(St.prototype.computeAABB = function() {}),
(St.prototype.computeDistanceAABB = function(t) {
throw "computeDistanceAABB is an abstract function of SDFPrimitive. Please reimplement it in children classes.";
}),
(St.prototype.getAreas = function() {
throw "No Areas for SDFPrimitive.";
}),
(St.prototype.distanceTo = ((Vt = {v: 0}),
function(t) {
return this.value(t, Vt), Vt.v;
})),
(St.prototype.heuristicStepWithin = function() {
throw "Not implemented";
});
var Mt = St,
Tt = function(t, e) {
Mt.call(this), (this.p = t.clone()), (this.acc = e || 1);
};
((Tt.prototype = Object.create(Mt.prototype)).constructor = Tt),
(Tt.type = "SDFPoint"),
s.register(Tt.type, Tt),
(Tt.prototype.getType = function() {
return Tt.type;
}),
(Tt.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.acc = this.acc), t;
}),
(Tt.fromJSON = function(e) {
return new Tt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.acc);
}),
(Tt.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(Tt.prototype.getAccuracy = function() {
return this.acc;
}),
(Tt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(Tt.prototype.getPosition = function() {
return this.p;
}),
(Tt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-e, -e, -e)),
this.p.clone().add(new t.Vector3(e, e, e))
);
}),
(Tt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Tt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{aabb: this.computeDistanceAABB(t), bv: new L(this.p, t, this.acc), obj: this}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Tt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var r = e.length();
(i.v = r), i.g && i.g.copy(e).multiplyScalar(1 / r);
};
})());
var Bt = Tt,
Pt = function(e, i, r, s, o, n) {
J.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = r),
(this.r2 = s),
(this.accFactor1 = o || 1),
(this.accFactor2 = n || 1),
(this.unit_dir = new t.Vector3().subVectors(i, e)),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize(),
(this.vector = new t.Vector3()),
(this.p1_to_p = this.vector),
(this.p1_to_p_sqrnorm = 0),
(this.x_p_2D = 0),
(this.y_p_2D = 0),
(this.y_p_2DSq = 0),
(this.ortho_vec_x = this.r1 - this.r2),
(this.ortho_vec_y = this.length),
(this.p_proj_x = 0),
(this.p_proj_y = 0),
(this.abs_diff_thick = Math.abs(this.ortho_vec_x));
};
((Pt.prototype = Object.create(J.prototype)).constructor = Pt),
(Pt.prototype.proj_computation = function(t) {
(this.p1_to_p = this.vector),
this.p1_to_p.subVectors(t, this.p1),
(this.p1_to_p_sqrnorm = this.p1_to_p.lengthSq()),
(this.x_p_2D = this.p1_to_p.dot(this.unit_dir)),
(this.y_p_2DSq = this.p1_to_p_sqrnorm - this.x_p_2D * this.x_p_2D),
(this.y_p_2D = this.y_p_2DSq > 0 ? Math.sqrt(this.y_p_2DSq) : 0);
var e = -this.y_p_2D / this.ortho_vec_y;
(this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x), (this.p_proj_y = 0);
}),
(Pt.prototype.sphereIntersect = function(t) {
if ((this.proj_computation(t.center), this.p_proj_x < 0))
return Math.sqrt(this.p1_to_p_sqrnorm) - t.radius < this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t.center, this.p2),
Math.sqrt(this.vector.lengthSq()) - t.radius < this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = e * e + this.y_p_2DSq,
r = this.p_proj_x / this.length,
s = this.r1 * (1 - r) + r * this.r2,
o = t.radius + s;
return i < o * o;
}),
(Pt.prototype.contains = function(t) {
if ((this.proj_computation(t), this.p_proj_x < 0))
return this.p1_to_p_sqrnorm < this.r1 * this.r1;
if (this.p_proj_x > this.length)
return (
this.vector.subVectors(t, this.p2), this.vector.lengthSq() < this.r2 * this.r2
);
var e = this.x_p_2D - this.p_proj_x,
i = this.y_p_2D - this.p_proj_y,
r = e * e + i * i,
s = this.p_proj_x / this.length,
o = this.r1 * (1 - s) + s * this.r2;
return r < o * o;
}),
(Pt.prototype.getAcc = function(t, e) {
this.proj_computation(t.center);
var i = this.abs_diff_thick / this.length,
r = t.radius * Math.sqrt(1 + i * i) * 0.5,
s = this.p_proj_x;
if ((s += this.r1 > this.r2 ? r : -r) < 0) return this.r1 * this.accFactor1 * e;
if (s > this.length) return this.r2 * this.accFactor2 * e;
var o = s / this.length;
return (
(this.r1 * this.accFactor1 * (1 - o) + o * this.r2 * this.accFactor2) * e
);
}),
(Pt.prototype.getNiceAcc = function(t) {
return this.getAcc(t, G.nice);
}),
(Pt.prototype.getCurrAcc = function(t) {
return this.getAcc(t, G.curr);
}),
(Pt.prototype.getRawAcc = function(t) {
return this.getAcc(t, G.raw);
}),
(Pt.prototype.getMinAcc = function() {
return G.curr * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getMinRawAcc = function() {
return G.raw * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
}),
(Pt.prototype.getAxisProjectionMinStep = function(t, e) {
var i,
r,
s,
o = Number.MAX_VALUE,
n = this.p1[t] < this.p2[t] ? this.p1 : this.p2;
n === this.p1
? ((i = this.p2),
  (r = this.r1 * this.accFactor1),
  (s = this.r2 * this.accFactor2))
: ((i = this.p1), (r = this.r2), (s = this.r1 * this.accFactor1));
var h = e - n[t];
h < -2 * r
? (o = Math.min(o, Math.max(Math.abs(h + 2 * r), G.curr * r)))
: h < 2 * r && (o = Math.min(o, G.curr * r)),
(h = e - i[t]) < -2 * s
? (o = Math.min(o, Math.max(Math.abs(h + 2 * s), G.curr * s)))
: h < 2 * s && (o = Math.min(o, G.curr * s));
var a = e - n[t],
c = i[t] - n[t];
return (
a > 0 &&
a < c &&
0 !== c &&
(o = Math.min(o, G.curr * (r + (a / c) * (s - r)))),
o
);
});
var kt = Pt,
Ft = function(e, i, r) {
Mt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.acc = r || 1),
(this.l = new t.Line3(this.p1, this.p2));
};
((Ft.prototype = Object.create(Mt.prototype)).constructor = Ft),
(Ft.type = "SDFSegment"),
s.register(Ft.type, Ft),
(Ft.prototype.getType = function() {
return Ft.type;
}),
(Ft.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.acc = this.acc),
t
);
}),
(Ft.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new Ft(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.acc
);
}),
(Ft.prototype.setAccuracy = function(t) {
(this.acc = t), this.invalidAABB();
}),
(Ft.prototype.getAccuracy = function() {
return this.acc;
}),
(Ft.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(Ft.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(Ft.prototype.getPosition1 = function() {
return this.p1;
}),
(Ft.prototype.getPosition2 = function() {
return this.p2;
}),
(Ft.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-e, -e, -e)),
this.p1.clone().add(new t.Vector3(e, e, e))
),
r = new t.Box3(
this.p2.clone().add(new t.Vector3(-e, -e, -e)),
this.p2.clone().add(new t.Vector3(e, e, e))
);
return i.union(r);
}),
(Ft.prototype.prepareForEval = function() {
this.valid_aabb || (this.l.set(this.p1, this.p2), (this.valid_aabb = !0));
}),
(Ft.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new kt(this.p1, this.p2, t, t, this.acc, this.acc),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Ft.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(t, r) {
this.l.closestPointToPoint(t, !0, e),
(r.v = i.subVectors(t, e).length()),
r.g && r.g.copy(i).divideScalar(r.v);
};
})());
var Nt = Ft,
Dt = function(t, e) {
Mt.call(this), (this.p = t.clone()), (this.r = e);
};
((Dt.prototype = Object.create(Mt.prototype)).constructor = Dt),
(Dt.type = "SDFSphere"),
s.register(Dt.type, Dt),
(Dt.prototype.getType = function() {
return Dt.type;
}),
(Dt.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (t.p = {x: this.p.x, y: this.p.y, z: this.p.z}), (t.r = this.r), t;
}),
(Dt.fromJSON = function(e) {
return new Dt(new t.Vector3(e.p.x, e.p.y, e.p.z), e.r);
}),
(Dt.prototype.setRadius = function(t) {
(this.r = t), this.invalidAABB();
}),
(Dt.prototype.getRadius = function() {
return this.r;
}),
(Dt.prototype.setPosition = function(t) {
this.p.copy(t), this.invalidAABB();
}),
(Dt.prototype.getPosition = function() {
return this.p;
}),
(Dt.prototype.computeDistanceAABB = function(e) {
return new t.Box3(
this.p.clone().add(new t.Vector3(-this.r - e, -this.r - e, -this.r - e)),
this.p.clone().add(new t.Vector3(this.r + e, this.r + e, this.r + e))
);
}),
(Dt.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Dt.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new L(this.p, this.r + t, this.r / (this.r + t)),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Dt.prototype.value = (function() {
var e = new t.Vector3();
return function(t, i) {
if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
e.subVectors(t, this.p);
var r = e.length();
(i.v = r - this.r), i.g && i.g.copy(e).multiplyScalar(1 / r);
};
})());
var zt = Dt,
Ot = function(e, i, r, s) {
Mt.call(this),
(this.p1 = e.clone()),
(this.p2 = i.clone()),
(this.r1 = r),
(this.r2 = s),
(this.r1 = this.r1),
(this.rdiff = this.r2 - this.r1),
(this.unit_dir = new t.Vector3().subVectors(this.p2, this.p1)),
(this.lengthSq = this.unit_dir.lengthSq()),
(this.length = this.unit_dir.length()),
this.unit_dir.normalize();
};
((Ot.prototype = Object.create(Mt.prototype)).constructor = Ot),
(Ot.type = "SDFCapsule"),
s.register(Ot.type, Ot),
(Ot.prototype.getType = function() {
return Ot.type;
}),
(Ot.prototype.toJSON = function() {
var t = Mt.prototype.toJSON.call(this);
return (
(t.p1 = {x: this.p1.x, y: this.p1.y, z: this.p1.z}),
(t.r1 = this.r1),
(t.p2 = {x: this.p2.x, y: this.p2.y, z: this.p2.z}),
(t.r2 = this.r2),
t
);
}),
(Ot.fromJSON = function(e) {
ScalisVertex.fromJSON(e.v[0]);
return new Ot(
new t.Vector3(e.p1.x, e.p1.y, e.p1.z),
new t.Vector3(e.p2.x, e.p2.y, e.p2.z),
e.r1,
e.r2
);
}),
(Ot.prototype.setRadius1 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Ot.prototype.setRadius2 = function(t) {
(this.r1 = t), this.invalidAABB();
}),
(Ot.prototype.getRadius1 = function() {
return this.r1;
}),
(Ot.prototype.getRadius2 = function() {
return this.r2;
}),
(Ot.prototype.setPosition1 = function(t) {
this.p1.copy(t), this.invalidAABB();
}),
(Ot.prototype.setPosition2 = function(t) {
this.p2.copy(t), this.invalidAABB();
}),
(Ot.prototype.getPosition1 = function() {
return this.p1;
}),
(Ot.prototype.getPosition2 = function() {
return this.p2;
}),
(Ot.prototype.computeDistanceAABB = function(e) {
var i = new t.Box3(
this.p1.clone().add(new t.Vector3(-this.r1 - e, -this.r1 - e, -this.r1 - e)),
this.p1.clone().add(new t.Vector3(this.r1 + e, this.r1 + e, this.r1 + e))
),
r = new t.Box3(
this.p2.clone().add(new t.Vector3(-this.r2 - e, -this.r2 - e, -this.r2 - e)),
this.p2.clone().add(new t.Vector3(this.r2 + e, this.r2 + e, this.r2 + e))
);
return i.union(r);
}),
(Ot.prototype.prepareForEval = function() {
this.valid_aabb || (this.valid_aabb = !0);
}),
(Ot.prototype.getAreas = function(t) {
if (this.valid_aabb)
return [
{
aabb: this.computeDistanceAABB(t),
bv: new kt(
this.p1,
this.p2,
this.r1 + t,
this.r2 + t,
this.r1 / (this.r1 + t),
this.r2 / (this.r2 + t)
),
obj: this
}
];
throw "ERROR : Cannot get area of invalid primitive";
}),
(Ot.prototype.value = (function() {
var e = new t.Vector3(),
i = new t.Vector3();
return function(r, s) {
e.subVectors(r, this.p1);
var o = e.lengthSq(),
n = e.dot(this.unit_dir),
h =
n + (-Math.sqrt(Math.max(0, o - n * n)) / this.length) * (this.r1 - this.r2),
a = t._Math.clamp(h / this.length, 0, 1);
i.copy(this.p1).lerp(this.p2, a);
var c = e.subVectors(r, i).length();
(s.v = c - (a * this.r2 + (1 - a) * this.r1)),
s.g && s.g.copy(e).divideScalar(c);
};
})());
var Et = Ot,
qt = {
EdgeVMap: [
[0, 4],
[1, 5],
[2, 6],
[3, 7],
[0, 2],
[1, 3],
[4, 6],
[5, 7],
[0, 1],
[2, 3],
[4, 5],
[6, 7]
],
VertexTopo: [
[0, 0, 0],
[0, 0, 1],
[0, 1, 0],
[0, 1, 1],
[1, 0, 0],
[1, 0, 1],
[1, 1, 0],
[1, 1, 1]
]
},
jt = function(e, i, r, s) {
if ((t.Box2.call(this, e, i), null == r)) {
var o = Math.max(this.max.x - this.min.x, this.max.y - this.min.y);
this.nice_acc = o <= 0 ? 1e7 : o;
} else this.nice_acc = r;
this.raw_acc = null == s ? this.nice_acc : s;
};
((jt.prototype = Object.create(t.Box2.prototype)).union = function(e) {
t.Box2.prototype.union.call(this, e),
(this.raw_acc = Math.min(e.raw_acc, this.raw_acc)),
(this.nice_acc = Math.min(e.nice_acc, this.nice_acc));
}),
(jt.prototype.getRawAcc = function() {
return this.raw_acc;
}),
(jt.prototype.getNiceAcc = function() {
return this.nice_acc;
}),
(jt.prototype.setRawAcc = function(t) {
this.raw_acc = Math.max(0, t);
}),
(jt.prototype.setNiceAcc = function(t) {
this.nice_acc = Math.max(0, t);
}),
(jt.prototype.toString = function() {
return (
"(" +
this.min.x.toFixed(2) +
", " +
this.min.y.toFixed(2) +
") -> (" +
this.max.x.toFixed(2) +
", " +
this.max.y.toFixed(2) +
") "
);
}),
(jt.prototype.set = function(t, e, i, r, s, o) {
this.min.set(t, e),
this.max.set(i, r),
void 0 !== s && (this.nice_acc = s),
void 0 !== o && (this.raw_acc = o);
}),
(jt.prototype.getMinCorner = function() {
return this.min;
});
var Rt,
Ct,
It = function(e, i) {
i = i || {};
(this.blobtree = e),
(this.detail_ratio = i.detailRatio ? Math.max(0.01, i.detailRatio) : 1),
i.convergence
? ((this.convergence = i.convergence),
  (this.convergence.ratio = this.convergence.ratio || 0.01),
  (this.convergence.step = this.convergence.step || 10))
: (this.convergence = null),
(this.reso = new Int32Array(3)),
(this.steps = {x: null, y: null, z: null}),
(this.curr_steps = {x: 0, y: 0, z: 0}),
(this.curr_step_vol = 0),
(this.values_xy = [null, null]),
(this.vertices_xy = [null, null]),
(this.areas = []),
(this.min_acc = 1),
(this.values = new Array(8)),
(this.x = 0),
(this.y = 0),
(this.z = 0),
(this.mask = 0),
(this.edge_cross = [!1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1]),
(this.vertex = new t.Vector3(0, 0, 0)),
(this.vertex_n = new t.Vector3(0, 0, 0)),
(this.vertex_m = new _()),
(this.extended = !1),
(this.dis_o_aabb = new t.Box3()),
(this.ext_p = new t.Vector3()),
(this.geometry = null);
};
(It.prototype.initGeometry = function() {
this.geometry = {
position: [],
normal: [],
color: [],
metalness: [],
roughness: [],
nVertices: 0,
faces: [],
nFaces: 0,
addVertex: function(t) {
this.position.push(t.p.x, t.p.y, t.p.z),
this.normal.push(t.n.x, t.n.y, t.n.z),
this.color.push(t.c.r, t.c.g, t.c.b),
this.roughness.push(t.r),
this.metalness.push(t.m),
this.nVertices++;
},
addFace: function(t, e, i) {
this.faces.push(t, e, i), this.nFaces++;
}
};
}),
(It.prototype.buildResultingBufferGeometry = function() {
var e = new t.BufferGeometry();
return (
e.addAttribute(
"position",
new t.BufferAttribute(new Float32Array(this.geometry.position), 3)
),
e.addAttribute(
"normal",
new t.BufferAttribute(new Float32Array(this.geometry.normal), 3)
),
e.addAttribute(
"color",
new t.BufferAttribute(new Float32Array(this.geometry.color), 3)
),
e.addAttribute(
"roughness",
new t.BufferAttribute(new Float32Array(this.geometry.roughness), 1)
),
e.addAttribute(
"metalness",
new t.BufferAttribute(new Float32Array(this.geometry.metalness), 1)
),
e.setIndex(
new t.BufferAttribute(
this.geometry.nVertices > 65535
? new Uint32Array(this.geometry.faces)
: new Uint16Array(this.geometry.faces),
1
)
),
e
);
}),
(It.prototype.setFrontToZero = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = 0;
}),
(It.prototype.setFrontToMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = -1;
}),
(It.prototype.setFrontToZeroIfMinus = function() {
for (var t = 0; t < this.values_xy[1].length; ++t)
-1 === this.values_xy[1][t] && (this.values_xy[1][t] = 0);
}),
(It.prototype.interpolateInBox = function(t, e, i, r, s, o, n) {
var h = this.values_xy[1],
a = s - r,
c = n - o;
if (a > 1)
for (
var p = h[(v = o * this.reso[0]) + r], l = (h[v + s] - p) / a, u = 1;
u < a;
++u
)
-1 === h[v + r + u] && (h[v + r + u] = p + u * l);
if (c > 1) {
var v;
for (
p = h[(v = n * this.reso[0]) + r], l = (h[v + s] - p) / a, u = 1;
u < a;
++u
)
-1 === h[v + r + u] && (h[v + r + u] = p + u * l);
for (u = 0; u <= a; ++u) {
(p = h[o * this.reso[0] + r + u]), (l = (h[n * this.reso[0] + r + u] - p) / c);
for (var _ = 1; _ < c; ++_)
-1 === h[(o + _) * this.reso[0] + r + u] &&
(h[(o + _) * this.reso[0] + r + u] = p + _ * l);
}
}
}),
(It.prototype.computeFrontValAt = function(t, e, i, r, s) {
this.computeFrontValAtClosure(t, e, i, r, s);
}),
(It.prototype.computeFrontValAtClosure = ((Rt = {v: 0}),
(Ct = new t.Vector3()),
function(t, e, i, r, s) {
var o = s * this.reso[0] + r;
(Rt.v = this.blobtree.getNeutralValue()),
-1 === this.values_xy[1][o] &&
(Ct.set(t + r * this.min_acc, e + s * this.min_acc, i),
this.blobtree.value(Ct, Rt),
(this.values_xy[1][o] = Rt.v));
})),
(It.prototype.computeFrontValAtBoxCorners = function(t, e, i, r, s) {
this.computeFrontValAt(t, e, i, r.x, r.y),
this.computeFrontValAt(t, e, i, r.x, s.y),
this.computeFrontValAt(t, e, i, s.x, r.y),
this.computeFrontValAt(t, e, i, s.x, s.y);
}),
(It.prototype.computeFrontValInBox = function(t, e, i, r, s) {
for (var o = r.x; o <= s.x; ++o)
for (var n = r.y; n <= s.y; ++n) this.computeFrontValAt(t, e, i, o, n);
}),
(It.prototype.setFrontValZeroInBox = function(t, e) {
for (var i = t.x; i <= e.x; ++i)
for (var r = t.y; r <= e.y; ++r) this.values_xy[1][r * this.reso[0] + i] = 0;
}),
(It.prototype.computeBoxMask = function(t, e) {
var i = 0;
return (
(i |=
this.values_xy[1][t.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 1
: 0),
(i |=
this.values_xy[1][t.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 2
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + e.x] > this.blobtree.getIsoValue()
? 4
: 0),
(i |=
this.values_xy[1][e.y * this.reso[0] + t.x] > this.blobtree.getIsoValue()
? 8
: 0)
);
}),
(It.prototype.checkZeroBox = function(t, e) {
return (
this.values_xy[1][t.y * this.reso[0] + t.x] +
this.values_xy[1][t.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + e.x] +
this.values_xy[1][e.y * this.reso[0] + t.x]
);
}),
(It.prototype.recursiveBoxComputation = function(e, i, r, s, o) {
var n = null,
h = new t.Vector2(Math.round(s.max.x - s.min.x), Math.round(s.max.y - s.min.y));
if (h.x > 1 && h.x >= h.y) {
var a = s.min.x + Math.floor(h.x / 2);
(n = [
new jt(s.min, new t.Vector2(a, s.max.y), 1e4, 1e4),
new jt(new t.Vector2(a, s.min.y), s.max, 1e4, 1e4)
]),
this.computeFrontValAt(e, i, r, a, s.min.y),
this.computeFrontValAt(e, i, r, a, s.max.y);
} else {
if (!(h.y > 1)) return;
var c = s.min.y + Math.floor(h.y / 2);
(n = [
new jt(s.min, new t.Vector2(s.max.x, c), 1e4, 1e4),
new jt(new t.Vector2(s.min.x, c), s.max, 1e4, 1e4)
]),
this.computeFrontValAt(e, i, r, s.min.x, c),
this.computeFrontValAt(e, i, r, s.max.x, c);
}
for (var p = [[], []], l = 0; l < o.length; ++l)
for (var u = 0; u < n.length; ++u)
n[u].intersectsBox(o[l]) &&
(n[u].setRawAcc(Math.min(n[u].getRawAcc(), o[l].getRawAcc())),
n[u].setNiceAcc(Math.min(n[u].getNiceAcc(), o[l].getNiceAcc())),
p[u].push(o[l]));
for (u = 0; u < n.length; ++u) {
var v = n[u],
_ = v.getSize(new t.Vector3());
if (0 === p[u].length) this.setFrontValZeroInBox(v.min, v.max);
else if (_.x <= v.getRawAcc() && _.y <= v.getRawAcc()) {
var m = this.computeBoxMask(v.min, v.max);
15 === m || 0 === m
? this.interpolateInBox(e, i, r, v.min.x, v.max.x, v.min.y, v.max.y)
: _.x <= v.getNiceAcc() && _.y <= v.getNiceAcc()
? this.interpolateInBox(e, i, r, v.min.x, v.max.x, v.min.y, v.max.y)
: this.recursiveBoxComputation(e, i, r, v, p[u]);
} else this.recursiveBoxComputation(e, i, r, v, p[u]);
}
}),
(It.prototype.computeFrontValues = function(e, i, r) {
this.setFrontToMinus();
var s = this.blobtree.getAreas(),
o = new jt();
o.makeEmpty();
for (var n = [], h = 0; h < s.length; ++h) {
var a = Math.round((s[h].bv.getMinRawAcc() * this.detail_ratio) / this.min_acc),
c = Math.round((s[h].bv.getMinAcc() * this.detail_ratio) / this.min_acc),
p = Math.max(0, Math.floor((s[h].aabb.min.x - e) / this.min_acc)),
l = Math.max(0, Math.floor((s[h].aabb.min.y - i) / this.min_acc)),
u = Math.min(this.reso[0] - 1, Math.ceil((s[h].aabb.max.x - e) / this.min_acc)),
v = Math.min(this.reso[1] - 1, Math.ceil((s[h].aabb.max.y - i) / this.min_acc));
n.push(new jt(new t.Vector2(p, l), new t.Vector2(u, v), c, a)),
o.union(n[n.length - 1]);
}
o.intersect(
new jt(
new t.Vector2(0, 0),
new t.Vector2(this.reso[0], this.reso[1]),
o.getNiceAcc(),
o.getRawAcc()
)
),
this.computeFrontValAtBoxCorners(e, i, r, o.min, o.max),
this.recursiveBoxComputation(e, i, r, o, n),
this.setFrontToZeroIfMinus();
}),
(It.prototype.getMinAcc = function(t) {
for (
var e = this.blobtree.getAreas(), i = Number.MAX_VALUE, r = 0;
r < e.length;
r++
) {
var s = e[r];
if (s.aabb.intersectsBox(t) && s.bv) {
var o = s.bv.getMinAcc();
o < i && (i = o);
}
}
return i * this.detail_ratio;
}),
(It.prototype.getMaxAcc = function(t) {
for (var e = this.blobtree.getAreas(), i = 0, r = 0; r < e.length; r++) {
var s = e[r];
if (s.aabb.intersectsBox(t) && s.bv) {
var o = s.bv.getMinAcc();
o > i && (i = o);
}
}
return i * this.detail_ratio;
}),
(It.prototype.compute = function(e, i, r) {
this.initGeometry(), (this.progress = r || function(t) {});
var s = new Date();
this.blobtree.prepareForEval();
var o = null;
if (
((o = e ? e.clone() : this.blobtree.getAABB()),
(this.extended = void 0 !== i && i),
this.extended)
) {
for (
var n = o.getSize(new t.Vector3()),
h = Math.min(Math.min(this.getMinAcc(o), n[0]), Math.min(n[1], n[2])),
a = o.clone(),
c = o.clone(),
p = ["x", "y", "z"],
l = 0;
l < p.length;
++l
) {
a.max[p[l]] = o.min[p[l]] + h;
var u = this.getMaxAcc(a);
0 !== u && (c.min[p[l]] = c.min[p[l]] - u),
(a.max[p[l]] = o.max[p[l]] - h),
0 !== (u = this.getMaxAcc(a)) && (c.max[p[l]] = c.max[p[l]] + u);
}
o.copy(c);
}
var v = [],
_ = [];
if (
(e && (this.blobtree.externalTrim(o, v, _), this.blobtree.prepareForEval()),
(this.areas = this.blobtree.getAreas()),
0 === this.areas.length)
)
return this.progress(100), new t.BufferGeometry();
this.min_acc = 0 !== this.areas.length ? this.areas[0].bv.getMinAcc() : 1;
for (var m = 0; m < this.areas.length; ++m)
this.areas[m].bv.getMinAcc() < this.min_acc &&
(this.min_acc = this.areas[m].bv.getMinAcc());
this.min_acc = this.min_acc * this.detail_ratio;
var g = o.min,
y = o.getSize(new t.Vector3());
this.steps.z = new Float32Array(Math.ceil(y.z / this.min_acc) + 2);
g.z;
this.steps.z[0] = g.z;
for (
var d = 1, f = this.blobtree.getAreas();
this.steps.z[d - 1] < g.z + y.z;

) {
var b = y.z;
for (m = 0; m < f.length; ++m)
b = Math.min(
b,
f[m].bv.getAxisProjectionMinStep("z", this.steps.z[d - 1]) * this.detail_ratio
);
(this.steps.z[d] = this.steps.z[d - 1] + b), d++;
}
if (
((this.reso[2] = d),
(this.reso[0] = Math.ceil(y.x / this.min_acc) + 2),
(this.reso[1] = Math.ceil(y.y / this.min_acc) + 2),
this.extended)
) {
m = 0;
for (
this.dis_o_aabb.set(new t.Vector3(-1, -1, -1), new t.Vector3(-1, -1, -1));
m < this.reso[2] && -1 === this.dis_o_aabb.min.z;

)
this.steps.z[m] >= e.min.z && (this.dis_o_aabb.min.z = m), m++;
for (
m > this.reso[2] - 1 && (this.dis_o_aabb.min.z = this.reso[2] - 1),
m = this.reso[2] - 1;
m >= 0 && -1 === this.dis_o_aabb.max.z;

)
this.steps.z[m] < e.max.z && (this.dis_o_aabb.max.z = m), m--;
m < 0 && (this.dis_o_aabb.max.z = 0),
(this.dis_o_aabb.min.x = Math.round((e.min.x - o.min.x) / this.min_acc)),
(this.dis_o_aabb.min.y = Math.round((e.min.y - o.min.y) / this.min_acc)),
(this.dis_o_aabb.max.x =
this.reso[0] - 2 - Math.round((o.max.x - e.max.x) / this.min_acc)),
(this.dis_o_aabb.max.y =
this.reso[1] - 2 - Math.round((o.max.y - e.max.y) / this.min_acc));
}
(this.values_xy[0] = new Float32Array(this.reso[0] * this.reso[1])),
(this.values_xy[1] = new Float32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[0] = new Int32Array(this.reso[0] * this.reso[1])),
(this.vertices_xy[1] = new Int32Array(this.reso[0] * this.reso[1]));
var w = new t.Box3();
this.computeFrontValues(g.x, g.y, g.z);
for (var x = 0, V = 0; V < this.reso[2] - 1; ++V) {
var A = this.values_xy[0];
(this.values_xy[0] = this.values_xy[1]),
(this.values_xy[1] = A),
(A = this.vertices_xy[0]),
(this.vertices_xy[0] = this.vertices_xy[1]),
(this.vertices_xy[1] = A);
var S = this.steps.z[V + 1];
w.set(
new t.Vector3(g.x, g.y, S - this.min_acc / 64),
new t.Vector3(
g.x + this.reso[0] * this.min_acc,
g.y + this.reso[1] * this.min_acc,
S + this.min_acc / 64
)
),
this.blobtree.internalTrim(w),
this.blobtree.prepareForEval(),
this.computeFrontValues(g.x, g.y, S),
this.blobtree.internalUntrim(w),
this.blobtree.prepareForEval(),
(this.z = this.steps.z[V]),
(this.curr_steps.z = this.steps.z[V + 1] - this.steps.z[V]),
(this.curr_steps.x = this.min_acc),
(this.curr_steps.y = this.min_acc),
(this.curr_step_vol =
this.curr_steps.x * this.curr_steps.y * this.curr_steps.z);
for (var M = 0; M < this.reso[1] - 1; ++M)
for (var T = 0; T < this.reso[0] - 1; ++T)
(this.y = g.y + M * this.min_acc), this.fetchAndTriangulate(T, M, V, g);
Math.round((100 * V) / this.reso[2]) > x &&
((x = Math.round((100 * V) / this.reso[2])), this.progress(x));
}
e && (this.blobtree.untrim(v, _), this.blobtree.prepareForEval());
var B = new Date();
return (
console.log("Sliding Marching Cubes computed in " + (B - s) + "ms"),
(this.values_xy[0] = null),
(this.values_xy[1] = null),
(this.vertices_xy[0] = null),
(this.vertices_xy[1] = null),
this.progress(100),
this.buildResultingBufferGeometry()
);
}),
(It.prototype.fetchAndTriangulate = function(t, e, i, r) {
var s = e * this.reso[0] + t,
o = (e + 1) * this.reso[0] + t;
(this.values[0] = this.values_xy[0][s]),
(this.values[1] = this.values_xy[1][s]),
(this.values[2] = this.values_xy[0][o]),
(this.values[3] = this.values_xy[1][o]),
(this.values[4] = this.values_xy[0][s + 1]),
(this.values[5] = this.values_xy[1][s + 1]),
(this.values[6] = this.values_xy[0][o + 1]),
(this.values[7] = this.values_xy[1][o + 1]),
this.computeMask(),
0 !== this.mask &&
255 !== this.mask &&
((this.x = r.x + t * this.min_acc),
this.computeVertex(),
this.geometry.addVertex({
p: this.vertex,
n: this.vertex_n,
c: this.vertex_m.getColor(),
r: this.vertex_m.getRoughness(),
m: this.vertex_m.getMetalness()
}),
(this.vertices_xy[1][s] = this.geometry.nVertices - 1),
this.triangulate(t, e, i));
}),
(It.prototype.pushDirectFaces = function(t, e, i, r) {
this.geometry.addFace(t, e, i), this.geometry.addFace(i, r, t);
}),
(It.prototype.pushUndirectFaces = function(t, e, i, r) {
this.geometry.addFace(i, e, t), this.geometry.addFace(t, r, i);
}),
(It.prototype.triangulate = function(t, e, i) {
var r = e * this.reso[0] + t;
if (this.edge_cross[0] && 0 !== e && 0 !== i) {
var s = this.vertices_xy[1][r],
o = this.vertices_xy[1][(e - 1) * this.reso[0] + t],
n = this.vertices_xy[0][(e - 1) * this.reso[0] + t],
h = this.vertices_xy[0][r];
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
if (this.edge_cross[4] && 0 !== t && 0 !== i) {
(s = this.vertices_xy[1][r]),
(o = this.vertices_xy[0][r]),
(n = this.vertices_xy[0][r - 1]),
(h = this.vertices_xy[1][r - 1]);
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
if (this.edge_cross[8] && 0 !== t && 0 !== e) {
(s = this.vertices_xy[1][r]),
(o = this.vertices_xy[1][r - 1]),
(n = this.vertices_xy[1][(e - 1) * this.reso[0] + t - 1]),
(h = this.vertices_xy[1][(e - 1) * this.reso[0] + t]);
1 & this.mask
? this.pushDirectFaces(s, o, n, h)
: this.pushUndirectFaces(s, o, n, h);
}
}),
(It.prototype.computeVertex = function() {
this.computeVertexClosure();
}),
(It.prototype.computeVertexClosure = (function() {
var e = {v: null, g: new t.Vector3(0, 0, 0), m: new _()},
i = new t.Vector3();
return function() {
e.v = this.blobtree.getNeutralValue();
var t = 0;
this.vertex.set(0, 0, 0);
for (var r = 0; r < 12; ++r) {
var s = qt.EdgeVMap[r][0],
o = qt.EdgeVMap[r][1],
n = qt.VertexTopo[s],
h = qt.VertexTopo[o],
a = this.values[s],
c = this.values[o];
if (
((this.edge_cross[r] =
a > this.blobtree.getIsoValue() != c > this.blobtree.getIsoValue()),
this.edge_cross[r])
) {
++t;
var p = c - a,
l = 0;
Math.abs(p) > 1e-6 &&
((l = (this.blobtree.getIsoValue() - a) / p),
(this.vertex.x += (1 - l) * n[0] + l * h[0]),
(this.vertex.y += (1 - l) * n[1] + l * h[1]),
(this.vertex.z += (1 - l) * n[2] + l * h[2]));
}
}
(this.vertex.x = this.x + (this.curr_steps.x * this.vertex.x) / t),
(this.vertex.y = this.y + (this.curr_steps.y * this.vertex.y) / t),
(this.vertex.z = this.z + (this.curr_steps.z * this.vertex.z) / t),
this.convergence &&
(u.safeNewton3D(
this.blobtree,
this.vertex,
this.blobtree.getIsoValue(),
this.min_acc * this.convergence.ratio,
this.convergence.step,
this.min_acc,
i
),
this.vertex.copy(i)),
this.blobtree.value(this.vertex, e),
e.g.normalize(),
this.vertex_n.copy(e.g).multiplyScalar(-1),
this.vertex_m.copy(e.m);
};
})()),
(It.prototype.computeMask = function() {
this.mask = 0;
for (var t = 0; t < 8; ++t) {
var e = this.values[t];
this.mask |= e > this.blobtree.getIsoValue() ? 1 << t : 0;
}
});
var Jt = It;
96 !== t.REVISION &&
console.warn(
"Blobtree library is currently made for THREE revision 96. Using any other revision may lead to unexpected behavior."
);
var Kt = {version: "1.0.0"};
return (
(Kt.Types = s),
(Kt.Element = h),
(Kt.Node = p),
(Kt.RootNode = M),
(Kt.RicciNode = A),
(Kt.DifferenceNode = B),
(Kt.MinNode = k),
(Kt.Primitive = N),
(Kt.ScalisMath = z),
(Kt.ScalisPrimitive = E),
(Kt.ScalisPoint = W),
(Kt.ScalisSegment = it),
(Kt.ScalisTriangle = mt),
(Kt.ScalisVertex = R),
(Kt.DistanceFunctor = yt),
(Kt.Poly6DistanceFunctor = ft),
(Kt.SDFRootNode = At),
(Kt.SDFPrimitive = Mt),
(Kt.SDFPoint = Bt),
(Kt.SDFSegment = Nt),
(Kt.SDFSphere = zt),
(Kt.SDFCapsule = Et),
(Kt.Material = _),
(Kt.Accuracies = G),
(Kt.Area = J),
(Kt.AreaScalisSeg = tt),
(Kt.AreaScalisTri = vt),
(Kt.AreaSphere = L),
(Kt.AreaCapsule = kt),
(Kt.SlidingMarchingCubes = Jt),
Kt
);
});
