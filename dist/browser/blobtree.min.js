!function(t, e) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e(require("three-full/builds/Three.cjs.js")) : "function" == typeof define && define.amd ? define([ "three-full/builds/Three.cjs.js" ], e) : t.Blobtree = e(t.THREE);
}(this, function(D) {
    "use strict";
    D = D && D.hasOwnProperty("default") ? D.default : D;
    var o, n, t = {
        types: {},
        register: function(t, e) {
            if (this.types[t]) throw "Error : cannot register type " + t + ", this name is already registered.";
            this.types[t] = e;
        },
        fromJSON: function(t) {
            var e = this.types[t.type];
            if (!e) throw "Error : type found in JSON (" + t.type + " is not registered in the Blobtree library.";
            return e.fromJSON(t);
        }
    }, r = t, e = 0, i = function() {
        this.id = e++, this.aabb = new D.Box3(), this.valid_aabb = !1, this.parentNode = null;
    };
    (i.prototype.constructor = i).type = "Element", r.register(i.type, i), i.prototype.toJSON = function() {
        return {
            type: this.getType()
        };
    }, i.prototype.getParentNode = function() {
        return this.parentNode;
    }, i.prototype.getType = function() {
        return i.type;
    }, i.prototype.computeHelpVariables = function() {
        this.computeAABB();
    }, i.prototype.computeAABB = function() {
        throw "Error : computeAABB is abstract, should have been overwritten";
    }, i.prototype.getAABB = function() {
        return this.aabb;
    }, i.prototype.isValidAABB = function() {
        return this.valid_aabb;
    }, i.prototype.invalidAABB = function() {
        this.valid_aabb = !1, null !== this.parentNode && this.parentNode.isValidAABB() && this.parentNode.invalidAABB();
    }, i.prototype.invalidAll = function() {
        this.invalidAABB();
    }, i.prototype.prepareForEval = function() {
        throw "ERROR : prepareForEval is a virtual function, should be re-implemented in all element(error occured in Element.js";
    }, i.prototype.value = function(t, e) {
        throw "ERROR : value is an abstract function, should be re-implemented in all primitives(error occured in " + this.getType() + " primitive)";
    }, i.prototype.numericalGradient = (o = {
        v: 0
    }, n = [ "x", "y", "z" ], function(t, e, i) {
        for (var r = i || 1e-5, s = 0; s < 3; ++s) t[n[s]] = t[n[s]] + r, this.value(t, o), 
        e[n[s]] = o.v, t[n[s]] = t[n[s]] - 2 * r, this.value(t, o), e[n[s]] = (e[n[s]] - o.v) / (2 * r), 
        t[n[s]] = t[n[s]] + r;
    }), i.prototype.getAreas = function() {
        return [];
    }, i.prototype.distanceTo = function(t) {
        throw "ERROR : distanceTo is a virtual function, should be re-implemented in all primitives(error occured in " + this.getType() + " primitive)";
    }, i.prototype.heuristicStepWithin = function() {
        throw "ERROR : heuristicStepWithin is a virtual function, should be re-implemented in all primitives(error occured in " + this.getType() + " primitive)";
    }, i.prototype.trim = function(t, e, i) {}, i.prototype.count = function(t) {
        return 0;
    };
    var s = i, h = function() {
        s.call(this), this.children = [];
    };
    ((h.prototype = Object.create(s.prototype)).constructor = h).type = "Node", r.register(h.type, h), 
    h.prototype.getType = function() {
        return h.type;
    }, h.prototype.toJSON = function() {
        var t = s.prototype.toJSON.call(this);
        t.children = [];
        for (var e = 0; e < this.children.length; ++e) t.children.push(this.children[e].toJSON());
        return t;
    }, h.prototype.prepareForEval = function() {
        console.error("prepareForEval is a pure virtual function, should be reimplemented in every node class");
    }, h.prototype.invalidAll = function() {
        if (this.invalidAABB(), this.children) for (var t = 0; t < this.children.length; t++) this.children[t].invalidAll();
    }, h.prototype.destroy = function() {
        for (var t = this.children.slice(0, this.children.length), e = 0; e < t.length; e++) t[e].destroy();
        if (0 !== this.children.length) throw "Error : children length should be 0";
        if (null !== this.parentNode && this.parentNode.removeChild(this), null !== this.parentNode) throw "Error : parent node should be null at this point";
        this.children.length = 0;
    }, h.prototype.addChild = function(t) {
        null !== t.parentNode && t.parentNode.removeChild(t), this.children.push(t), (t.parentNode = this).invalidAABB();
    }, h.prototype.removeChild = function(t) {
        for (var e = 0, i = this.children; i[e] !== t && e < i.length; ) ++e;
        if (e == i.length) throw "c does not belong to the children of this node";
        i[e] = i[i.length - 1], i.pop(), this.invalidAABB(), t.parentNode = null;
    }, h.prototype.computeAABB = function() {
        this.aabb.makeEmpty();
        for (var t = 0; t < this.children.length; t++) this.children[t].computeAABB(), this.aabb.union(this.children[t].getAABB());
    }, h.prototype.getAreas = function() {
        if (!this.valid_aabb) throw "Error : cannot call getAreas on a not prepared for eval nod, please call PrepareForEval first. Node concerned is a " + this.getType();
        for (var t = [], e = 0; e < this.children.length; e++) t.push.apply(t, this.children[e].getAreas());
        return t;
    }, h.prototype.distanceTo = function(t) {
        for (var e = 1e7, i = 0; i < this.children.length; i++) e = Math.min(e, this.children[i].distanceTo(t));
        return e;
    }, h.prototype.heuristicStepWithin = function() {
        for (var t = 1e7, e = 0; e < this.children.length; e++) t = Math.min(t, this.children[e].heuristicStepWithin());
        return t;
    }, h.prototype.trim = function(t, e, i) {
        for (var r = e.length, s = 0; s < this.children.length; s++) this.children[s].getAABB().intersectsBox(t) || (e.push(this.children[s]), 
        i.push(this));
        for (s = r; s < e.length; ++s) this.removeChild(e[s]);
        for (s = 0; s < this.children.length; s++) this.children[s].trim(t, e, i);
    }, h.prototype.count = function(t) {
        var e = 0;
        this instanceof t && e++;
        for (var i = 0; i < this.children.length; i++) e += this.children[i].count(t);
        return e;
    };
    var a = h, p = {};
    p.last_mov_pt = new D.Vector3(), p.grad = new D.Vector3(), p.eval_res_g = new D.Vector3(0, 0, 0), 
    p.eval_res = {
        v: 0,
        g: null
    }, p.vec = new D.Vector3(), p.safeNewton3D = function(t, e, i, r, s, o, n) {
        n.copy(e);
        for (var h = 1, a = 0, c = !1; 2 != a && h <= s && !c; ) {
            if (this.last_mov_pt.copy(n), this.eval_res.g = this.eval_res_g, t.value(n, this.eval_res), 
            this.grad.copy(this.eval_res.g), 0 !== this.grad.x || 0 !== this.grad.y || 0 !== this.grad.z) {
                var p = this.grad.length(), l = (i - this.eval_res.v) / p;
                if (l < r && -r < l ? (l = 0 < l ? r / p : -r / p, a++) : a = 0, this.grad.normalize().multiplyScalar(l), 
                n.add(this.grad), this.vec.subVectors(n, e).lengthSq() > o * o) return void n.copy(e);
            } else c = !0;
            ++h;
        }
        c && n.copy(e);
    }, p.safeNewton1D = function(t, e, i, r, s, o, n, h, a, c) {
        if (this.eval_res.g = this.eval_res_g, 0 === i.x && 0 === i.y && 0 === i.z) throw "Error : search direction is null";
        if (h <= 0) throw "Error: epsilon <= 0, convergence will nuke your face or loop";
        if (o < r || s < o) throw "Error : starting absc is not in boundaries";
        for (var p = o, l = new D.Vector3(), u = 0, _ = 0; h < s - r && _ < a; ) t.value(l.copy(i).multiplyScalar(p).add(e), this.eval_res), 
        this.eval_res.v > n ? r = p : s = p, 0 !== (u = this.eval_res.g.dot(i)) ? (s <= (p += (n - this.eval_res.v) / u) || p <= r) && (p = .5 * (s + r)) : p = .5 * (s + r), 
        ++_;
        c.p_absc = .5 * (s + r), c.p.copy(i).multiplyScalar(p).add(e), void 0 !== c.g && (0 === _ && t.value(c.p, this.eval_res), 
        c.g.copy(this.eval_res.g));
    }, p.dichotomy1D = function(t, e, i, r, s, o, n, h) {
        this.eval_res.g = null;
        var a = new D.Vector3().copy(e), c = new D.Vector3(), p = -(r /= 2), l = p;
        e.sub(c.copy(i).multiplyScalar(r));
        for (var u = 0; o < r && u < n; ) u++, a.copy(e), l = p, r /= 2, t.value(e, this.eval_res), 
        this.eval_res.v < s ? (e.add(c.copy(i).multiplyScalar(r)), p += r) : (e.sub(c.copy(i).multiplyScalar(r)), 
        p -= r);
        h.p.copy(e.add(a).divideScalar(2)), h.p_absc = (l + p) / 2, h.p.copy(e), h.p_absc = p, 
        h.g && (this.eval_res.g = this.eval_res_g, t.value(h.p, this.eval_res), h.g.copy(this.eval_res.g));
    };
    var l = p, u = function(t, e, i) {
        this.color = new D.Color(null != t ? t : 11184810), this.roughness = e || 0, this.metalness = i || 0;
    };
    u.prototype.toJSON = function() {
        return {
            color: "#" + this.color.getHexString(),
            roughness: this.roughness,
            metalness: this.metalness
        };
    }, u.fromJSON = function(t) {
        return new u(new D.Color(t.color), t.roughness, t.metalness);
    }, u.prototype.clone = function() {
        return new u(this.color, this.roughness, this.metalness);
    }, u.prototype.copy = function(t) {
        this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness;
    }, u.prototype.set = function(t, e, i) {
        this.color.copy(t), this.roughness = e, this.metalness = i;
    }, u.prototype.getColor = function() {
        return this.color;
    }, u.prototype.getRoughness = function() {
        return this.roughness;
    }, u.prototype.getMetalness = function() {
        return this.metalness;
    }, u.prototype.equals = function(t) {
        return this.color.equals(t.color) && this.metalness === t.metalness && this.roughness === t.roughness;
    }, u.prototype.lerp = function(t, e) {
        this.color.lerp(t.color, e), this.roughness = (1 - e) * this.roughness + e * t.roughness, 
        this.metalness = (1 - e) * this.metalness + e * t.metalness;
    }, u.prototype.triMean = function(t, e, i, r, s, o, n) {
        return this.color.r = (r * t.color.r + s * e.color.r + o * i.color.r) / n, this.color.g = (r * t.color.g + s * e.color.g + o * i.color.g) / n, 
        this.color.b = (r * t.color.b + s * e.color.b + o * i.color.b) / n, this.roughness = (r * t.roughness + s * e.roughness + o * i.roughness) / n, 
        this.metalness = (r * t.metalness + s * e.metalness + o * i.metalness) / n, this;
    }, u.prototype.weightedMean = function(t, e, i) {
        this.color.setRGB(0, 0, 0), this.roughness = 0;
        for (var r = void (this.metalness = 0) === i ? t.length : i, s = 0, o = 0; o < r; ++o) this.color.r += e[o] * t[o].color.r, 
        this.color.g += e[o] * t[o].color.g, this.color.b += e[o] * t[o].color.b, this.roughness += e[o] * t[o].roughness, 
        this.metalness += e[o] * t[o].metalness, s += e[o];
        return 0 !== s ? (this.color.r /= s, this.color.g /= s, this.color.b /= s, this.roughness /= s, 
        this.metalness /= s) : (this.color.r = 0, this.color.g = 0, this.color.b = 0, this.roughness = 0, 
        this.metalness = 0), this;
    }, u.areEqualsArrays = function(t, e, i, r, s) {
        console.warn("Material.areEqualsArrays is deprecated, please use your own comparison function using Material.equals.");
        for (var o = !0, n = 1; n < arguments.length; n++) o = o && (null === t && null === arguments[n] || null !== t && null !== arguments[n]);
        if (!o) return o;
        if (null === t) return !0;
        for (n = 1; n < arguments.length; n++) {
            var h = !0;
            if (arguments[n].length !== t.length) return !1;
            for (var a = 0; a < t.length; ++a) h = h && t[a].equals(arguments[n][a]);
            o = o && h;
        }
        return o;
    }, u.defaultMaterial = new u();
    var _ = u, v = function(t, e) {
        if (a.call(this), this.ricci_n = t, e) {
            var i = this;
            e.forEach(function(t) {
                i.addChild(t);
            });
        }
        this.tmp_v_arr = new Float32Array(0), this.tmp_m_arr = new Array(0), this.tmp_res = {
            v: 0,
            g: null,
            m: null
        }, this.tmp_g = new D.Vector3(), this.tmp_m = new _(null, null, null);
    };
    ((v.prototype = Object.create(a.prototype)).constructor = v).type = "RicciNode", 
    r.register(v.type, v), v.prototype.getType = function() {
        return v.type;
    }, v.prototype.toJSON = function() {
        var t = a.prototype.toJSON.call(this);
        return t.ricci = this.ricci_n, t;
    }, v.fromJSON = function(t) {
        for (var e = new v(t.ricci), i = 0; i < t.children.length; ++i) e.addChild(r.fromJSON(t.children[i]));
        return e;
    }, v.prototype.prepareForEval = function() {
        if (!this.valid_aabb) {
            this.aabb = new D.Box3();
            for (var t = 0; t < this.children.length; ++t) {
                var e = this.children[t];
                e.prepareForEval(), this.aabb.union(e.getAABB());
            }
            if (this.valid_aabb = !0, this.tmp_v_arr.length < this.children.length) {
                this.tmp_v_arr = new Float32Array(2 * this.children.length), this.tmp_m_arr.length = 2 * this.children.length;
                for (t = 0; t < this.tmp_m_arr.length; ++t) this.tmp_m_arr[t] = new _(null, 0, 0);
            }
        }
    }, v.prototype.value = function(t, e) {
        var i = this.children.length, r = this.tmp_res;
        if (r.g = e.g ? this.tmp_g : null, r.m = e.m ? this.tmp_m : null, e.v = 0, e.m && e.m.copy(_.defaultMaterial), 
        e.g ? e.g.set(0, 0, 0) : e.step && (e.step = 1e9), this.aabb.containsPoint(t) && 0 !== i) {
            for (var s = this.tmp_v_arr, o = this.tmp_m_arr, n = 0, h = 0, a = 0; a < i; ++a) if (this.children[a].aabb.containsPoint(t)) if (this.children[a].value(t, r), 
            this.countEval++, 0 < r.v) {
                var c = Math.pow(r.v, this.ricci_n - 1);
                h += r.v * c, e.g && (r.g.multiplyScalar(c), e.g.add(r.g)), e.m && (s[n] = r.v * c, 
                o[n].copy(r.m), n++), (e.step || e.stepOrtho) && (e.step = Math.min(e.step, this.children[a].heuristicStepWithin()));
            } else this.countEval0++, e.step && (e.step = Math.min(e.step, this.children[a].distanceTo(t))); else (e.step || e.stepOrtho) && (e.step = Math.min(e.step, this.children[a].distanceTo(t)));
            e.v = Math.pow(h, 1 / this.ricci_n), 0 !== e.v && (e.g && e.g.multiplyScalar(e.v / h), 
            e.m && e.m.weightedMean(o, s, n));
        } else e.step && (e.step = this.aabb.distanceToPoint(t) + .3);
        e.step && (e.stepOrtho = e.step);
    }, v.prototype.setRicciN = function(t) {
        this.ricci_n != t && (this.ricci_n = t, this.invalidAABB());
    }, v.prototype.getRicciN = function() {
        return this.ricci_n;
    };
    var m, g, y, d, f, b, w, x, V, A, S, M, T, B, P, k, F, N = v, z = function() {
        N.call(this, 64), this.valid_aabb = !0, this.iso_value = 1, this.trimmed = [], this.trim_parents = [];
    };
    ((z.prototype = Object.create(N.prototype)).constructor = z).type = "RootNode", 
    r.register(z.type, z), z.prototype.getType = function() {
        return z.type;
    }, z.prototype.toJSON = function() {
        var t = N.prototype.toJSON.call(this);
        return t.iso = this.iso_value, t;
    }, z.fromJSON = function(t) {
        for (var e = new z(t.ricci), i = 0; i < t.children.length; ++i) e.addChild(r.fromJSON(t.children[i]));
        return e;
    }, z.prototype.getIsoValue = function() {
        return this.iso_value;
    }, z.prototype.setIsoValue = function(t) {
        this.iso_value = t;
    }, z.prototype.getNeutralValue = function() {
        return 0;
    }, z.prototype.invalidAABB = function() {
        this.valid_aabb = !1;
    }, z.prototype.internalTrim = function(t) {
        if (0 !== this.trimmed.length || 0 !== this.trim_parents.length) throw "Error : you should not call internal trim if you have not untrimmed before. Call untrim or use externalTrim";
        this.trim(t, this.trimmed, this.trim_parents);
    }, z.prototype.externalTrim = function(t, e, i) {
        this.trim(t, e, i);
    }, z.prototype.internalUntrim = function() {
        this.untrim(this.trimmed, this.trim_parents), this.trimmed.length = 0, this.trim_parents.length = 0;
    }, z.prototype.untrim = function(t, e) {
        if (t.length !== e.length) throw "Error : trimmed and parents arrays should have the same length";
        for (var i = 0; i < t.length; ++i) e[i].addChild(t[i]);
    }, z.prototype.isEmpty = function() {
        return 0 == this.children.length;
    }, z.prototype.intersectRayBlob = (g = new D.Vector3(), y = new D.Vector3(), d = new D.Vector3(), 
    f = {
        v: 0,
        g: new D.Vector3()
    }, b = {
        p: new D.Vector3(),
        g: new D.Vector3(),
        p_absc: 0
    }, V = x = w = 0, function(t, e, i, r) {
        for (g.copy(t.origin), y.copy(t.direction), y.normalize(), V = 0, f.g = null, this.value(g, f); f.v < m && V < i; ) g.add(d.copy(y).multiplyScalar(f.step)), 
        V += f.step, w = f.step, x = f.v, this.value(g, f);
        return f.v >= m && (Convergence.safeNewton1D(this, g, y.multiplyScalar(-1), 0, w, w * (m - f.v) / (x - f.v), m, w / 512, 10, b), 
        e.distance = V - b.absc, e.point = b.p.clone(), e.g && e.g.copy(b.g), !0);
    }), z.prototype.intersectOrthoRayBlob = (A = new D.Vector3(), S = new D.Vector3(), 
    M = {
        step: 0
    }, T = new D.Vector3(), B = {}, k = P = 0, F = -1, function(t, e, i, r) {
        for (r.axis.z ? A.set(this.aabb.min.x + t, this.aabb.min.y + e, this.aabb.min.z + 1e-7) : r.axis.y ? A.set(this.aabb.min.x + t, this.aabb.min.y + 1e-7, this.aabb.min.z + e) : r.axis.z && A.set(this.aabb.min.x + 1e-7, this.aabb.min.y + t, this.aabb.min.z + e), 
        M.step = r.get(this.aabb.max) - r.get(this.aabb.min), this.value(A, M), P = 1e-7, 
        F = -1; r.get(A) < r.get(this.aabb.max); ) {
            for (;0 <= (M.v - 1) * F && r.get(A) < r.get(this.aabb.max); ) r.add(A, M.step), 
            P = M.step, M.step = r.get(this.aabb.max) - r.get(A), this.value(A, M);
            if (r.get(A) < r.get(this.aabb.max)) {
                for (F *= -1, S.copy(A), k = r.get(A), P /= 2, r.add(A, -P), B.g = null; .1 < P; ) k = r.get(A), 
                P /= 2, this.value(A, B), (B.v - 1) * F < 0 ? r.add(A, P) : r.add(A, -P);
                r.add(A, k), r.divide(A, 2), B.g = T, this.value(A, B), i.push({
                    point: A.clone(),
                    gradient: B.g.clone()
                }), A.copy(S);
            }
        }
    });
    var O = z, E = function(t, e, i) {
        a.call(this), this.addChild(t), this.addChild(e), this.alpha = i || 1, this.clamped = 0, 
        this.tmp_res0 = {
            v: 0,
            g: new D.Vector3(0, 0, 0),
            m: new _(null, null, null)
        }, this.tmp_res1 = {
            v: 0,
            g: new D.Vector3(0, 0, 0),
            m: new _(null, null, null)
        }, this.g0 = new D.Vector3(), this.m0 = new _(null, null, null), this.g1 = new D.Vector3(), 
        this.m1 = new _(null, null, null), this.tmp_v_arr = new Float32Array(2), this.tmp_m_arr = [ null, null ];
    };
    ((E.prototype = Object.create(a.prototype)).constructor = E).type = "DifferenceNode", 
    r.register(E.type, E), E.prototype.getAlpha = function() {
        return this.alpha;
    }, E.prototype.setAlpha = function(t) {
        this.alpha != t && (this.alpha = t, this.invalidAABB());
    }, E.prototype.toJSON = function() {
        var t = a.prototype.toJSON.call(this);
        return t.alpha = this.alpha, t;
    }, E.fromJSON = function(t) {
        var e = new E();
        return this.children[0] = r.fromJSON(t.children[0]), this.children[1] = r.fromJSON(t.children[1]), 
        e;
    }, E.prototype.prepareForEval = function() {
        this.valid_aabb || (this.children[0].prepareForEval(), this.children[1].prepareForEval(), 
        this.aabb.copy(this.children[0].getAABB()), this.valid_aabb = !0);
    }, E.prototype.value = function(t, e) {
        this.children.length;
        var i = this.tmp_v_arr, r = this.tmp_m_arr, s = this.tmp_res0, o = this.tmp_res1;
        if (s.g = e.g ? this.g0 : null, s.m = e.m ? this.m0 : null, o.g = e.g ? this.g1 : null, 
        o.m = e.m ? this.m1 : null, e.v = 0, o.v = 0, s.v = 0, e.m && (e.m.copy(_.defaultMaterial), 
        o.m.copy(_.defaultMaterial), s.m.copy(_.defaultMaterial)), e.g ? (e.g.set(0, 0, 0), 
        o.g.set(0, 0, 0), s.g.set(0, 0, 0)) : e.step && (e.step = 1e9), this.aabb.containsPoint(t)) {
            if (this.children[0].aabb.containsPoint(t)) if (this.children[0].value(t, s), this.children[1].aabb.containsPoint(t) && this.children[1].value(t, o), 
            0 === o.v) e.v = s.v, e.g && e.g.copy(s.g), e.m && e.m.copy(s.m); else {
                var n = Math.pow(o.v, this.alpha);
                e.v = Math.max(this.clamped, s.v - o.v * Math.pow(o.v, this.alpha - 1)), e.g && (e.v === this.clamped ? e.g.set(0, 0, 0) : (o.g.multiplyScalar(n), 
                e.g.subVectors(s.g, o.g))), e.m && (i[0] = s.v, i[1] = o.v, r[0] = s.m, r[1] = o.m, 
                e.m.weightedMean(r, i, 2));
            }
        } else e.step && (e.step = this.aabb.distanceToPoint(t) + .3);
    }, E.prototype.trim = function(t, e, i) {
        for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
    };
    var q = E, j = function(t) {
        if (a.call(this), t) {
            var e = this;
            t.forEach(function(t) {
                e.addChild(t);
            });
        }
        this.tmp_res = {
            v: 0,
            g: null,
            m: null
        }, this.tmp_g = new D.Vector3(), this.tmp_m = new _(null, null, null);
    };
    ((j.prototype = Object.create(a.prototype)).constructor = j).type = "MinNode", r.register(j.type, j), 
    j.prototype.getType = function() {
        return j.type;
    }, j.fromJSON = function(t) {
        for (var e = new j(), i = 0; i < t.children.length; ++i) e.addChild(r.fromJSON(t.children[i]));
        return e;
    }, j.prototype.prepareForEval = function() {
        if (!this.valid_aabb) {
            this.aabb = new D.Box3();
            for (var t = 0; t < this.children.length; ++t) {
                var e = this.children[t];
                e.prepareForEval(), this.aabb.union(e.getAABB());
            }
            this.valid_aabb = !0;
        }
    }, j.prototype.value = function(t, e) {
        var i = this.children.length, r = this.tmp_res;
        if (r.g = e.g ? this.tmp_g : null, r.m = e.m ? this.tmp_m : null, e.v = 0, e.m && e.m.copy(_.defaultMaterial), 
        e.g ? e.g.set(0, 0, 0) : e.step && (e.step = 1e9), this.aabb.containsPoint(t) && 0 !== i) {
            e.v = Number.MAX_VALUE;
            for (var s = 0; s < i; ++s) {
                if (this.children[s].value(t, r), this.countEval++, r.v < e.v && (e.v = r.v, e.g && e.g.copy(r.g), 
                e.m && e.m.copy(r.m), e.step || e.stepOrtho)) throw "Not implemented";
                e.v = Math.min(e.v, r.v);
            }
        } else if (e.steo || e.stepOrtho) throw "Not implemented";
    }, j.prototype.trim = function(t, e, i) {
        for (var r = 0; r < this.children.length; r++) this.children[r].trim(t, e, i);
    };
    var R = j, C = function() {
        s.call(this), this.materials = [];
    };
    ((C.prototype = Object.create(s.prototype)).constructor = C).type = "Primitive", 
    r.register(C.type, C), C.prototype.toJSON = function(t) {
        var e = s.prototype.toJSON.call(this);
        e.materials = [];
        for (var i = 0; i < this.materials.length; ++i) e.materials.push(this.materials[i].toJSON());
        return e;
    }, C.prototype.setMaterials = function(t) {
        if (t.length !== this.materials.length) throw "Error : trying to set " + t.length + " materials on a primitive with only " + this.materials.length;
        for (var e = 0; e < t.length; ++e) t[e].equals(this.materials[e]) || (this.materials[e].copy(t[e]), 
        this.invalidAABB());
    }, C.prototype.getMaterials = function() {
        return this.materials;
    }, C.prototype.computeAABB = function() {
        throw "Primitive.prototype.computeAABB  Must be reimplemented in all inherited class.";
    }, C.prototype.destroy = function() {
        null !== this.parentNode && this.parentNode.removeChild(this);
    }, C.prototype.getAreas = function() {
        throw "ERROR : getAreas is an abstract function, should be re-implemented in all primitives(error occured in " + this.getType() + " primitive)";
    }, C.prototype.computeHelpVariables = function() {
        throw "ERROR : computeHelpVariables is a virtual function, should be re-implemented in all primitives(error occured in " + this.getType() + " primitive)";
    }, C.prototype.count = function(t) {
        return this instanceof t ? 1 : 0;
    };
    var I = C, J = {
        KS: 2
    };
    J.KIS = 1 / J.KS, J.KS2 = 4, J.KIS2 = 1 / (J.KS * J.KS), J.Poly6Eval = function(t) {
        var e = 1 - J.KIS2 * t * t;
        return 0 < e ? e * e * e : 0;
    }, J.Poly6EvalSq = function(t) {
        var e = 1 - J.KIS2 * t;
        return 0 < e ? e * e * e : 0;
    }, J.GetIsoValueAtDistanceGeom0D = function(t, e, i) {
        if (t % 2 != 0) throw "degree should be even";
        if (i < e) {
            var r = 1 - i * i / (e * e);
            return Math.pow(r, t / 2);
        }
        return 0;
    }, J.Poly4NF0D = 1 / J.GetIsoValueAtDistanceGeom0D(4, J.KS, 1), J.Poly6NF0D = 1 / J.GetIsoValueAtDistanceGeom0D(6, J.KS, 1), 
    J.GetIsoValueAtDistanceGeom1D = function(t, e, i) {
        if (t % 2 != 0) throw "degree should be even";
        if (i < e) {
            for (var r = 1 - i * i / (e * e), s = 2 * e * Math.sqrt(r), o = 0; o != t; ) s *= (o += 2) / (1 + o) * r;
            return s;
        }
        return 0;
    }, J.Poly4NF1D = 1 / J.GetIsoValueAtDistanceGeom1D(4, J.KS, 1), J.Poly6NF1D = 1 / J.GetIsoValueAtDistanceGeom1D(6, J.KS, 1), 
    J.GetIsoValueAtDistanceGeom2D = function(t, e, i) {
        if (i < e) {
            var r = t + 2, s = 1 - i * i / (e * e);
            return 2 * Math.PI / r * e * e * Math.pow(s, .5 * r);
        }
        return 0;
    }, J.Poly4NF2D = 1 / J.GetIsoValueAtDistanceGeom2D(4, J.KS, 1), J.Poly6NF2D = 1 / J.GetIsoValueAtDistanceGeom2D(6, J.KS, 1);
    var K = J, G = function() {
        I.call(this), this.volType = G.DIST, this.v = [];
    };
    G.DIST = "dist", G.CONVOL = "convol", G.prototype = Object.create(I.prototype), 
    (G.prototype.constructor = G).type = "ScalisPrimitive", r.register(G.type, G), G.prototype.getType = function() {
        return G.type;
    }, G.prototype.toJSON = function() {
        var t = I.prototype.toJSON.call(this);
        t.v = [], t.volType = this.volType;
        for (var e = 0; e < this.v.length; ++e) t.v.push(this.v[e].toJSON());
        return t;
    }, G.prototype.mutableVolType = function() {
        return !1;
    }, G.prototype.setVolType = function(t) {
        t !== this.volType && (this.volType = t, this.invalidAABB());
    }, G.prototype.getVolType = function() {
        return this.volType;
    }, G.prototype.computeAABB = function() {
        this.aabb.makeEmpty();
        for (var t = 0; t < this.v.length; t++) this.aabb.union(this.v[t].getAABB());
    };
    var H = G, L = 0, U = function(t, e) {
        this.pos = t.clone(), this.thickness = e, this.id = L++, this.prim = null, this.aabb = new D.Box3(), 
        this.valid_aabb = !1;
    };
    U.prototype.setPrimitive = function(t) {
        null === this.prim && (this.prim = t);
    }, U.prototype.toJSON = function() {
        return {
            position: {
                x: this.pos.x,
                y: this.pos.y,
                z: this.pos.z
            },
            thickness: this.thickness
        };
    }, U.fromJSON = function(t) {
        return new U(new D.Vector3(t.position.x, t.position.y, t.position.z), t.thickness);
    }, U.prototype.setPos = function(t) {
        this.valid_aabb = !1, this.pos.copy(t), this.prim.invalidAABB();
    }, U.prototype.setThickness = function(t) {
        this.valid_aabb = !1, this.thickness = t, this.prim.invalidAABB();
    }, U.prototype.setAll = function(t, e) {
        this.valid_aabb = !1, this.pos = t, this.thickness = e, this.prim.invalidAABB();
    }, U.prototype.getPos = function() {
        return this.pos;
    }, U.prototype.getThickness = function() {
        return this.thickness;
    }, U.prototype.getAABB = function() {
        return this.valid_aabb || (this.computeAABB(), this.valid_aabb = !0), this.aabb;
    }, U.prototype.computeAABB = function() {
        var t = this.getPos(), e = this.getThickness() * K.KS;
        this.aabb.set(new D.Vector3(t.x - e, t.y - e, t.z - e), new D.Vector3(t.x + e, t.y + e, t.z + e));
    }, U.prototype.equals = function(t) {
        return this.pos.equals(t.pos) && this.thickness === t.thickness;
    };
    var W = U, Z = function() {};
    Z.prototype.sphereIntersect = function(t) {
        throw "Error : sphereIntersect is abstract, should have been overwritten";
    }, Z.prototype.contains = function(t) {
        throw "Error : contains is abstract, should have been overwritten";
    }, Z.prototype.getAcc = function(t, e) {
        throw "Error : getAcc is abstract, should have been overwritten";
    }, Z.prototype.getNiceAcc = function(t) {
        throw "Error : getNiceAcc is abstract, should have been overwritten";
    }, Z.prototype.getCurrAcc = function(t) {
        throw "Error : getCurrAcc is abstract, should have been overwritten";
    }, Z.prototype.getRawAcc = function(t) {
        throw "Error : getRawAcc is abstract, should have been overwritten";
    }, Z.prototype.getMinAcc = function() {
        throw "Error : getRawAcc is abstract, should have been overwritten";
    }, Z.prototype.getMinRawAcc = function() {
        throw "Error : getRawAcc is abstract, should have been overwritten";
    };
    var X, Q, Y = Z, $ = {
        nice: .3,
        raw: 1,
        curr: .3
    }, tt = $, et = function(t, e, i) {
        Y.call(this), this.p = new D.Vector3(t.x, t.y, t.z), this.r = e, this.accFactor = i || 1;
    };
    ((et.prototype = Object.create(Y.prototype)).constructor = et).prototype.sphereIntersect = (X = new D.Vector3(), 
    function(t) {
        X.subVectors(t.center, this.p);
        var e = t.radius + this.radius;
        return X.lengthSq() < e * e;
    }), et.prototype.contains = (Q = new D.Vector3(), function(t) {
        return Q.subVectors(t, this.p), Q.lengthSq() < this.r * this.r;
    }), et.prototype.getAcc = function(t, e) {
        return this.radius * e;
    }, et.prototype.getNiceAcc = function(t) {
        return this.getAcc(t, tt.nice * this.accFactor);
    }, et.prototype.getCurrAcc = function(t) {
        return this.getAcc(t, tt.curr * this.accFactor);
    }, et.prototype.getRawAcc = function(t) {
        return this.getAcc(t, tt.raw * this.accFactor);
    }, et.prototype.getMinAcc = function() {
        return tt.curr * this.r * this.accFactor;
    }, et.prototype.getMinRawAcc = function() {
        return tt.raw * this.r * this.accFactor;
    }, et.prototype.getAxisProjectionMinStep = function(t, e) {
        var i = 1e8, r = e - this.p[t];
        return r < -2 * this.r ? i = Math.min(i, Math.max(Math.abs(r + this.r), tt.curr * this.r * this.accFactor)) : r < 2 * this.r && (i = Math.min(i, tt.curr * this.r * this.accFactor)), 
        i;
    };
    var it = et, rt = function(t, e, i, r) {
        H.call(this), this.v.push(t), this.v[0].setPrimitive(this), this.volType = H.DIST, 
        this.density = i, this.materials.push(r), this.v_to_p = new D.Vector3();
    };
    ((rt.prototype = Object.create(H.prototype)).constructor = rt).type = "ScalisPoint", 
    r.register(rt.type, rt), rt.prototype.getType = function() {
        return rt.type;
    }, rt.prototype.toJSON = function() {
        var t = H.prototype.toJSON.call(this);
        return t.density = this.density, t;
    }, rt.fromJSON = function(t) {
        var e = W.fromJSON(t.v[0]), i = _.fromJSON(t.materials[0]);
        return new rt(e, t.volType, t.density, i);
    }, rt.prototype.setDensity = function(t) {
        this.density = t, this.invalidAABB();
    }, rt.prototype.getDensity = function() {
        return this.density;
    }, rt.prototype.setMaterial = function(t) {
        this.materials[0].copy(t), this.invalidAABB();
    }, rt.prototype.computeHelpVariables = function() {
        this.computeAABB();
    }, rt.prototype.prepareForEval = function() {
        this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0);
    }, rt.prototype.getAreas = function() {
        if (this.valid_aabb) return [ {
            aabb: this.aabb,
            bv: new it(this.v[0].getPos(), K.KS * this.v[0].getThickness(), K.KIS),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, rt.prototype.heuristicStepWithin = function() {
        return this.v[0].getThickness() / 3;
    }, rt.prototype.value = function(t, e) {
        if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
        var i = this.v[0].getThickness();
        this.v_to_p.subVectors(t, this.v[0].getPos());
        var r = this.v_to_p.lengthSq() / (i * i), s = 1 - K.KIS2 * r;
        if (0 < s) {
            if (e.v = this.density * s * s * s * K.Poly6NF0D, e.g) {
                var o = -this.density * K.KIS2 * 6 * this.v_to_p.length() * s * s * K.Poly6NF0D / (i * i);
                e.g.copy(this.v_to_p).normalize().multiplyScalar(o);
            }
            e.m && e.m.copy(this.materials[0]);
        } else e.v = 0, e.g && e.g.set(0, 0, 0), e.m && e.m.copy(_.defaultMaterial);
    }, rt.prototype.distanceTo = function(t) {
        return t.distanceTo(this.v[0].getPos());
    };
    var st = rt, ot = function(t, e, i, r) {
        Y.call(this), this.p0 = new D.Vector3(t.x, t.y, t.z), this.p1 = new D.Vector3(e.x, e.y, e.z), 
        this.thick0 = i, this.thick1 = r, this.unit_dir = new D.Vector3().subVectors(e, t), 
        this.length = this.unit_dir.length(), this.unit_dir.normalize(), this.vector = new D.Vector3(), 
        this.p0_to_p = this.vector, this.p0_to_p_sqrnorm = 0, this.x_p_2D = 0, this.y_p_2D = 0, 
        this.y_p_2DSq = 0, this.ortho_vec_x = this.thick0 - this.thick1, this.ortho_vec_y = this.length, 
        this.p_proj_x = 0, this.p_proj_y = 0, this.abs_diff_thick = Math.abs(this.ortho_vec_x);
    };
    ((ot.prototype = Object.create(Y.prototype)).constructor = ot).prototype.proj_computation = function(t) {
        this.p0_to_p = this.vector, this.p0_to_p.subVectors(t, this.p0), this.p0_to_p_sqrnorm = this.p0_to_p.lengthSq(), 
        this.x_p_2D = this.p0_to_p.dot(this.unit_dir), this.y_p_2DSq = this.p0_to_p_sqrnorm - this.x_p_2D * this.x_p_2D, 
        this.y_p_2D = 0 < this.y_p_2DSq ? Math.sqrt(this.y_p_2DSq) : 0;
        var e = -this.y_p_2D / this.ortho_vec_y;
        this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x, this.p_proj_y = 0;
    }, ot.prototype.sphereIntersect = function(t) {
        if (this.proj_computation(t.center), this.p_proj_x < 0) return Math.sqrt(this.p0_to_p_sqrnorm) - t.radius < this.thick0 * K.KS;
        if (this.p_proj_x > this.length) return this.vector.subVectors(t.center, this.p1), 
        Math.sqrt(this.vector.lengthSq()) - t.radius < this.thick1 * K.KS;
        var e = this.x_p_2D - this.p_proj_x, i = e * e + this.y_p_2DSq, r = this.p_proj_x / this.length, s = this.thick0 * (1 - r) + r * this.thick1, o = t.radius + s * K.KS;
        return i < o * o;
    }, ot.prototype.contains = function(t) {
        if (this.proj_computation(t), this.p_proj_x < 0) return this.p0_to_p_sqrnorm < this.thick0 * this.thick0 * K.KS2;
        if (this.p_proj_x > this.length) return this.vector.subVectors(t, this.p1), this.vector.lengthSq() < this.thick1 * this.thick1 * K.KS2;
        var e = this.x_p_2D - this.p_proj_x, i = this.y_p_2D - this.p_proj_y, r = e * e + i * i, s = this.p_proj_x / this.length, o = this.thick0 * (1 - s) + s * this.thick1;
        return r < o * o * K.KS2;
    }, ot.prototype.getAcc = function(t, e) {
        this.proj_computation(t.center);
        var i = this.abs_diff_thick / this.length, r = t.radius * Math.sqrt(1 + i * i) * .5, s = this.p_proj_x;
        if ((s += this.thick0 > this.thick1 ? r : -r) < 0) return this.thick0 * e;
        if (s > this.length) return this.thick1 * e;
        var o = s / this.length;
        return (this.thick0 * (1 - o) + o * this.thick1) * e;
    }, ot.prototype.getNiceAcc = function(t) {
        return this.getAcc(t, tt.nice);
    }, ot.prototype.getCurrAcc = function(t) {
        return this.getAcc(t, tt.curr);
    }, ot.prototype.getRawAcc = function(t) {
        return this.getAcc(t, tt.raw);
    }, ot.prototype.getMinAcc = function() {
        return tt.curr * Math.min(this.thick0, this.thick1);
    }, ot.prototype.getMinRawAcc = function() {
        return tt.raw * Math.min(this.thick0, this.thick1);
    }, ot.prototype.getAxisProjectionMinStep = function(t, e) {
        var i, r, s, o = Number.MAX_VALUE, n = this.p0[t] < this.p1[t] ? this.p0 : this.p1;
        s = n === this.p0 ? (i = this.p1, r = this.thick0, this.thick1) : (i = this.p0, 
        r = this.thick1, this.thick0);
        var h = e - n[t];
        h < -2 * r ? o = Math.min(o, Math.max(Math.abs(h + 2 * r), tt.curr * r)) : h < 2 * r && (o = Math.min(o, tt.curr * r)), 
        (h = e - i[t]) < -2 * s ? o = Math.min(o, Math.max(Math.abs(h + 2 * s), tt.curr * s)) : h < 2 * s && (o = Math.min(o, tt.curr * s));
        var a = e - n[t], c = i[t] - n[t];
        return 0 < a && a < c && 0 !== c && (o = Math.min(o, tt.curr * (r + a / c * (s - r)))), 
        o;
    };
    var nt, ht, at, ct, pt = ot, lt = function(t, e, i, r, s) {
        H.call(this), this.v.length = 2, this.v[0] = t, this.v[1] = e, t.setPrimitive(this), 
        e.setPrimitive(this), this.volType = i, this.density = r, this.materials = s, this.clipped_l1 = 1, 
        this.clipped_l2 = 0, this.vector = new D.Vector3(), this.cycle = new D.Vector3(), 
        this.proj = new D.Vector3(), this.v0_p = this.v[0].getPos(), this.v1_p = this.v[1].getPos(), 
        this.dir = new D.Vector3(), this.lengthSq = 0, this.length = 0, this.unit_dir = new D.Vector3(), 
        this.weight_p1 = 0, this.c0 = 0, this.c1 = 0, this.increase_unit_dir = new D.Vector3(), 
        this.p_min = new D.Vector3(), this.weight_min = 0, this.inv_weight_min = 0, this.unit_delta_weight = 0, 
        this.maxbound = 0, this.maxboundSq = 0, this.cyl_bd0 = 0, this.cyl_bd1 = 0, this.f0f1f2 = new D.Vector3(), 
        this.tmpVec1 = new D.Vector3(), this.tmpVec2 = new D.Vector3(), this.computeHelpVariables();
    };
    lt.prototype = Object.create(H.prototype), (lt.constructor = lt).type = "ScalisSegment", 
    r.register(lt.type, lt), lt.prototype.getType = function() {
        return lt.type;
    }, lt.prototype.toJSON = function() {
        var t = H.prototype.toJSON.call(this);
        return t.density = this.density, t;
    }, lt.fromJSON = function(t) {
        var e = W.fromJSON(t.v[0]), i = W.fromJSON(t.v[1]), r = [ _.fromJSON(t.materials[1]), _.fromJSON(t.materials[1]) ];
        return new lt(e, i, t.volType, t.density, r);
    }, lt.prototype.mutableVolType = function() {
        return !0;
    }, lt.prototype.setDensity = function(t) {
        this.density = t, this.invalidAABB();
    }, lt.prototype.getDensity = function() {
        return this.density;
    }, lt.prototype.setVolType = function(t) {
        if (t != H.CONVOL && t != H.DIST) throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
        this.volType != t && (this.volType = t, this.invalidAABB());
    }, lt.prototype.getVolType = function() {
        return this.volType;
    }, lt.prototype.prepareForEval = function() {
        this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0);
    }, lt.prototype.getAreas = function() {
        if (this.valid_aabb) return [ {
            aabb: this.aabb,
            bv: new pt(this.v[0].getPos(), this.v[1].getPos(), this.v[0].getThickness(), this.v[1].getThickness(), this.length, this.unit_dir),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, lt.prototype.computeHelpVariables = function() {
        this.v0_p = this.v[0].getPos(), this.v1_p = this.v[1].getPos(), this.dir.subVectors(this.v1_p, this.v0_p), 
        this.lengthSq = this.dir.lengthSq(), this.length = Math.sqrt(this.lengthSq), this.unit_dir.copy(this.dir).normalize(), 
        this.weight_p1 = this.v[1].getThickness(), this.c0 = this.v[0].getThickness(), this.c1 = this.v[1].getThickness() - this.v[0].getThickness();
        var t = this.v[0].getThickness() * K.KS, e = this.v[1].getThickness() * K.KS;
        this.maxbound = Math.max(t, e), this.maxboundSq = this.maxbound * this.maxbound, 
        this.cyl_bd0 = Math.min(-t, this.length - e), this.cyl_bd1 = Math.max(this.length + e, t), 
        this.increase_unit_dir.copy(this.unit_dir), this.c1 < 0 ? (this.p_min.copy(this.v1_p), 
        this.weight_min = this.weight_p1, this.inv_weight_min = 1 / this.weight_p1, this.increase_unit_dir.negate(), 
        this.unit_delta_weight = -this.c1 / this.length) : (this.p_min.copy(this.v0_p), 
        this.weight_min = this.c0, this.inv_weight_min = 1 / this.c0, this.unit_delta_weight = this.c1 / this.length), 
        this.computeAABB();
    }, lt.prototype.value = function(t, e) {
        switch (this.volType) {
          case H.DIST:
            this.evalDist(t, e);
            break;

          case H.CONVOL:
            this.evalConvol(t, e);
            break;

          default:
            throw "Unknown volType, cannot evaluate.";
        }
    }, lt.prototype.evalDist = (nt = {
        v: 0
    }, ht = new D.Vector3(), function(t, e) {
        var i = this.vector;
        i.subVectors(t, this.v[0].getPos());
        var r = i.dot(this.dir), s = i.lengthSq(), o = this.lengthSq * this.c0 + r * this.c1, n = this.c1 < 0 ? 0 : 1;
        0 < o && (n = (n = r * this.c0 + s * this.c1) < 0 ? 0 : o < n ? 1 : n / o);
        var h = Math.sqrt(n * (n * this.lengthSq - 2 * r) + s), a = this.c0 + n * this.c1;
        if (e.v = this.density * K.Poly6Eval(h / a) * K.Poly6NF0D, e.m && this.evalMat(t, e), 
        e.g) {
            var c = 1e-5, p = this.density / c;
            ht.copy(t), ht.x += c, this.evalDist(ht, nt), e.g.x = p * (nt.v - e.v), ht.x -= c, 
            ht.y += c, this.evalDist(ht, nt), e.g.y = p * (nt.v - e.v), ht.y -= c, ht.z += c, 
            this.evalDist(ht, nt), e.g.z = p * (nt.v - e.v);
        }
    }), lt.prototype.evalMat = function(t, e) {
        var i = this.vector;
        i.subVectors(t, this.v[0].getPos());
        var r = this.unit_dir.dot(i) / this.length;
        1 < r ? e.m.copy(this.materials[1]) : r <= 0 ? e.m.copy(this.materials[0]) : (e.m.copy(this.materials[0]), 
        e.m.lerp(this.materials[1], r));
    }, lt.prototype.HomotheticClippingSpecial = function(t) {
        var e = -t.z, i = -t.y, r = -t.x, s = i * i - e * r;
        if (0 <= s) {
            var o = i + Math.sqrt(s);
            if (o < 0 || this.length * o < r) return !1;
            var n = r / o;
            this.clipped_l1 = n < 0 ? 0 : n;
            var h = e * n;
            return this.clipped_l2 = 2 * i < h + e * this.length ? r / h : this.length, !0;
        }
        return !1;
    }, lt.prototype.heuristicStepWithin = function() {
        return this.weight_min / 3;
    }, lt.prototype.evalConvol = function(t, e) {
        if (!this.valid_aabb) throw "Error : prepareForEval should have been called";
        e.g && e.g.set(0, 0, 0), e.v = 0;
        var i = this.tmpVec1;
        i.subVectors(t, this.p_min);
        var r = this.increase_unit_dir.dot(i), s = i.lengthSq(), o = this.tmpVec2;
        if (o.set(this.weight_min * this.weight_min - K.KIS2 * s, -this.unit_delta_weight * this.weight_min - K.KIS2 * r, this.unit_delta_weight * this.unit_delta_weight - K.KIS2), 
        this.HomotheticClippingSpecial(o)) {
            var n = 1 / (this.weight_min + this.clipped_l1 * this.unit_delta_weight);
            o.x = 1 - K.KIS2 * (this.clipped_l1 * (this.clipped_l1 - 2 * r) + s) * n * n, o.y = -this.unit_delta_weight - K.KIS2 * (r - this.clipped_l1) * n, 
            e.g ? (.06 <= this.unit_delta_weight ? this.HomotheticCompactPolynomial_segment_FGradF_i6((this.clipped_l2 - this.clipped_l1) * n, this.unit_delta_weight, o) : this.HomotheticCompactPolynomial_approx_segment_FGradF_i6((this.clipped_l2 - this.clipped_l1) * n, this.unit_delta_weight, this.inv_weight_min, o), 
            e.v = K.Poly6NF1D * this.f0f1f2.x, this.f0f1f2.y *= n, e.g.copy(this.increase_unit_dir).multiplyScalar(this.f0f1f2.z + this.clipped_l1 * this.f0f1f2.y).sub(i.multiplyScalar(this.f0f1f2.y)).multiplyScalar(6 * K.Poly6NF1D * K.KIS2 * n)) : .06 <= this.unit_delta_weight ? e.v = K.Poly6NF1D * this.HomotheticCompactPolynomial_segment_F_i6((this.clipped_l2 - this.clipped_l1) * n, this.unit_delta_weight, o) : e.v = K.Poly6NF1D * this.HomotheticCompactPolynomial_approx_segment_F_i6((this.clipped_l2 - this.clipped_l1) * n, this.unit_delta_weight, n, o), 
            e.m && this.evalMat(t, e);
        }
    }, lt.prototype.clamp = function(t, e, i) {
        return Math.max(e, Math.min(i, t));
    }, lt.prototype.distanceTo = (at = new D.Vector3(), ct = new D.Vector3(), function(t) {
        var e = at.subVectors(t, this.v[0].getPos()).dot(this.dir) / this.lengthSq;
        return e = this.clamp(e, 0, 1), ct.copy(this.dir).multiplyScalar(e).add(this.v[0].getPos()), 
        t.distanceTo(ct);
    }), lt.prototype.HomotheticCompactPolynomial_segment_F_i6 = function(t, e, i) {
        var r = e * t + 1, s = 1 / r, o = r * r, n = 1 / (o * o), h = i.y, a = h * h, c = 12 * a, p = 1 / e, l = h * p, u = r * o, _ = t * t, v = _ * _, m = t * _, g = t * v, y = i.x, d = i.z, f = y * y, b = d * d, w = 1 / (u * u), x = s * n, V = 1 / u, A = 1 / o;
        return -b * (((((-(s - 1) * p - t * A) * p - _ * V) * p - m * n) * p - v * x) * p - g * w) * l + (-y * (w - 1) * p / 6 - (-(x - 1) * p / 5 - t * w) * l) * f + ((y * c + 3 * d * f) * (.4 * (-(n - 1) * p / 4 - t * x) * p - _ * w) + (3 * b * y + d * c) * (.8 * (.75 * (2 / 3 * (-(A - 1) * p / 2 - t * V) * p - _ * n) * p - m * x) * p - v * w) + d * b * (1.2 * (5 / 4 * (4 / 3 * (1.5 * (2 * (Math.log(r) * p - t * s) * p - _ * A) * p - m * V) * p - v * n) * p - g * x) * p - m * m * w) + (-12 * d * y - 8 * a) * (.6 * ((-(V - 1) * p / 3 - t * n) * p / 2 - _ * x) * p - m * w) * h) * p / 6;
    }, lt.prototype.HomotheticCompactPolynomial_approx_segment_F_i6 = function(t, e, i, r) {
        var s = i * e, o = s + 1, n = 1 / o, h = o * o, a = n / (h * h) / h, c = r.z, p = r.y, l = r.x, u = t * t, _ = c * u - 2 * p * t + l, v = c * l - p * p, m = c * t - p, g = l * l, y = p * g, d = _ * _, f = m * d, b = 1 / c, w = v * b, x = 6 / 35 * (4 / 3 * (2 * v * t + m * _ + p * l) * w + f + y) * w + _ * f / 7 + l * y / 7, V = b * x, A = n * a, S = d * d, M = p * V + S / 8 - g * g / 8, T = -t * S + (-10 * p * M + l * x) * b;
        return V - 7 * e * M * b + (-.1111111111 * (3 * a - 3 + 7 * (2 + A) * s) * T - .1 * (2 - 2 * a - 7 * (1 + A) * s) / i * (-1 * u * S + (1.333333333 * p * T + 2 * l * M) * b)) * b / (i * i);
    }, lt.prototype.HomotheticCompactPolynomial_segment_FGradF_i6 = function(t, e, i) {
        var r = e * t + 1, s = 1 / r, o = r * r, n = 1 / (o * o), h = i.y, a = h * h, c = 2 * a, p = i.z, l = i.x, u = p * l / 3 + 2 / 3 * a, _ = p * p, v = _ / 6, m = -2 / 3 * p, g = r * o, y = 1 / g, d = s * n, f = 1 / (g * g), b = t * t, w = 1 / e, x = t * b, V = .6 * ((-(y - 1) * w / 3 - t * n) * w / 2 - b * d) * w - x * f, A = V * h, S = -(d - 1) * w / 5 - t * f, M = l * l, T = M * S, B = .4 * (-(n - 1) * w / 4 - t * d) * w - b * f, P = l * B, k = -M * (f - 1) / 6, F = b * b, N = t * F, D = 1 / o, z = .8 * (.75 * (2 / 3 * (-(D - 1) * w / 2 - t * y) * w - b * n) * w - x * d) * w - F * f, O = ((((-(s - 1) * w - t * D) * w - b * y) * w - x * n) * w - F * d) * w - N * f, E = x * x, q = Math.log(r);
        this.f0f1f2.x = (l * k - h * T + P * c - 4 / 3 * a * A + (M * B / 2 + z * c - 2 * l * A) * p + (l * z / 2 - h * O + (-E * f / 6 + (-N * d / 5 + (-F * n / 4 + (-x * y / 3 + (-b * D / 2 + (q * w - t * s) * w) * w) * w) * w) * w) * p) * _) * w, 
        this.f0f1f2.y = (k + B * u + z * v + (-2 / 3 * l * S + V * m) * h) * w, this.f0f1f2.z = (T / 6 + V * u + O * v + (-2 / 3 * P + z * m) * h) * w;
    }, lt.prototype.HomotheticCompactPolynomial_approx_segment_FGradF_i6 = function(t, e, i, r) {
        var s = i * e, o = s + 1, n = 1 / o, h = 1 / (i * i), a = o * o, c = n / (a * a) / a, p = r.x, l = 2 * p, u = r.z, _ = 1 / u, v = e * _, m = r.y, g = t * t, y = u * g - 2 * m * t + p, d = y * y, f = y * d, b = p * p, w = p * b, x = u * p - m * m, V = u * t - m, A = x * _, S = 4 / 3 * (2 * x * t + V * y + m * p) * A + V * d + m * b, M = S / 5, T = m * _ * M + f / 6 - w / 6, B = -t * f + (-8 * m * T + p * M) * _, P = g * f, k = (10 / 7 * m * B + T * l) * _ - P, F = -k / 8, N = 6 / 35 * S * A + V * f / 7 + m * w / 7, D = n * c, z = (3 * c - 3 + 7 * (2 + D) * s) * h, O = (2 - 2 * c - 7 * (1 + D) * s) / i * h, E = _ * z, q = _ * O, j = _ * N, R = d * d, C = m * j + R / 8 - b * b / 8, I = -t * R + (-10 * m * C + p * N) * _;
        this.f0f1f2.x = j - 7 * C * v - I * E / 9 - (-g * R + (4 / 3 * m * I + C * l) * _) * q / 10, 
        this.f0f1f2.y = (M - 7 * e * T - B * z / 7 + O * F) * _, this.f0f1f2.z = T * _ + B * v + E * F - (-t * P + (1.5 * m * k - 3 / 7 * p * B) * _) * q / 9;
    };
    var ut = lt, _t = 1e-6, vt = {}, mt = function(t, e) {
        var i = t;
        if (0 === e) throw "Lenght of the array should not be null";
        return 1 === e ? 0 : (t < 0 && (i = (e + t) % e), e <= t && (i = t % e), i);
    };
    vt.computeVectorsDirs = function(t) {
        var e = t.v[0].getPos(), i = t.v[1].getPos(), r = t.v[2].getPos();
        t.p0p1.subVectors(i, e), t.p1p2.subVectors(r, i), t.p2p0.subVectors(e, r), t.unit_normal.crossVectors(t.p0p1, t.p2p0), 
        t.unit_normal.normalize(), t.length_p0p1 = t.p0p1.length(), t.unit_p0p1.copy(t.p0p1), 
        t.unit_p0p1.divideScalar(t.length_p0p1), t.diffThick_p0p1 = t.v[0].getThickness() - t.v[1].getThickness(), 
        t.length_p1p2 = t.p1p2.length(), t.unit_p1p2.copy(t.p1p2), t.unit_p1p2.divideScalar(t.length_p1p2), 
        t.diffThick_p1p2 = t.v[1].getThickness() - t.v[2].getThickness(), t.length_p2p0 = t.p2p0.length(), 
        t.unit_p2p0.copy(t.p2p0), t.unit_p2p0.divideScalar(t.length_p2p0), t.diffThick_p2p0 = t.v[2].getThickness() - t.v[0].getThickness();
        var s = [];
        s.push({
            vert: t.v[0].getPos(),
            thick: t.v[0].getThickness(),
            idx: 0
        }), s.push({
            vert: t.v[1].getPos(),
            thick: t.v[1].getThickness(),
            idx: 1
        }), s.push({
            vert: t.v[2].getPos(),
            thick: t.v[2].getThickness(),
            idx: 2
        }), s.sort(function(t, e) {
            return t.thick - e.thick;
        }), t.point_min = s[0].vert, t.weight_min = s[0].thick;
        var o = mt(s[0].idx + 1, 3), n = t.v[o].getPos(), h = t.v[o].getThickness();
        o = mt(s[0].idx + 2, 3);
        var a = t.v[o].getPos(), c = t.v[o].getThickness(), p = new D.Vector3();
        p = p.subVectors(n, t.point_min);
        var l = new D.Vector3();
        l = l.subVectors(a, t.point_min);
        var u = h - t.weight_min, _ = c - t.weight_min;
        if (u < _t || _ < _t) {
            if (u < _) {
                t.ortho_dir = p.clone(), t.ortho_dir.normalize(), t.main_dir.crossVectors(t.ortho_dir, t.unit_normal), 
                t.main_dir.normalize(), t.main_dir.dot(l) < 0 && t.main_dir.multiplyScalar(-1);
                var v = -t.weight_min / _;
                t.point_iso_zero = new D.Vector3(t.point_min.x + v * l.x, t.point_min.y + v * l.y, t.point_min.z + v * l.z);
            } else {
                t.ortho_dir = l.clone(), t.ortho_dir.normalize(), t.main_dir.crossVectors(t.ortho_dir, t.unit_normal), 
                t.main_dir.normalize(), t.main_dir.dot(p) < 0 && t.main_dir.multiplyScalar(-1);
                v = -t.weight_min / u;
                t.point_iso_zero = new D.Vector3(t.point_min.x + v * p.x, t.point_min.y + v * p.y, t.point_min.z + v * p.z);
            }
            Math.abs(u - _) < _t && (t.proj_dir = t.unit_normal.clone().multiplyScalar(-1), 
            t.equal_weights = !0);
        } else {
            var m = -t.weight_min / u, g = new D.Vector3(t.point_min.x + m * p.x, t.point_min.y + m * p.y, t.point_min.z + m * p.z);
            t.point_iso_zero = g;
            var y = -t.weight_min / _, d = new D.Vector3(t.point_min.x + y * l.x, t.point_min.y + y * l.y, t.point_min.z + y * l.z);
            t.ortho_dir.subVectors(d, g), t.ortho_dir.normalize(), t.main_dir.crossVectors(t.ortho_dir, t.unit_normal), 
            t.main_dir.normalize(), (t.main_dir.dot(p) < 0 || t.main_dir.dot(l) < 0) && t.main_dir.multiplyScalar(-1);
        }
        var f = p.dot(t.main_dir), b = l.dot(t.main_dir);
        f = f < 0 ? 0 : f, b = b < 0 ? 0 : b;
        var w = null;
        t.unit_delta_weight = b < f ? (w = p, t.half_dir_1 = l, t.point_half = a, t.half_dir_2 = n.clone().subVectors(n, a), 
        t.coord_max = f, t.coord_middle = b / f * t.coord_max, u / t.coord_max) : (w = l, 
        t.half_dir_1 = p, t.point_half = n, t.half_dir_2 = a.clone().subVectors(a, n), t.coord_max = b, 
        t.coord_middle = f / b * t.coord_max, _ / t.coord_max), t.longest_dir_special = w.divideScalar(t.coord_max);
        var x = new D.Vector3();
        x.subVectors(t.half_dir_1, t.longest_dir_special.clone().multiplyScalar(t.coord_middle)), 
        t.max_seg_length = x.length(), t.unsigned_ortho_dir = t.ortho_dir.clone(), t.ortho_dir.dot(x) < 0 && t.ortho_dir.multiplyScalar(-1);
    }, vt.getParametrisedVertexAttr = function(t, e, i) {
        var r = vt.getMeanThick(t, e, i), s = new D.Vector3(), o = s.subVectors(t.v[1].getPos(), t.v[0].getPos()).multiplyScalar(e), n = s.clone().subVectors(t.v[2].getPos(), t.v[0].getPos()).multiplyScalar(i);
        return s.addVectors(t.v[0].getPos(), o), s.addVectors(s, n), {
            pos: s,
            thick: r
        };
    }, vt.getMeanThick = function(t, e, i) {
        return t.v[0].getThickness() * (1 - e - i) + t.v[1].getThickness() * e + t.v[2].getThickness() * i;
    }, vt.getMeanMat = function(t, e, i) {
        var r = new Material(null, null, null), s = null === t.materials ? [ t.v[0].getMaterial(), t.v[0].getMaterial(), t.v[0].getMaterial() ] : [ t.materials[0], t.materials[1], t.materials[2] ];
        return r.weightedMean(s, [ 1 - e - i, e, i ]), r;
    }, vt.getTriBaryCoord = function(t, e, i, r) {
        var s = t, o = e.clone().multiplyScalar(-1), n = new D.Vector3().subVectors(r, i), h = s.lengthSq(), a = s.dot(o), c = n.dot(s), p = o.lengthSq(), l = (h * n.dot(o) - a * c) / (h * p - a * a);
        return {
            u: (c - l * a) / h,
            v: l
        };
    }, vt.getUVCoord = function(t, e, i, r) {
        var s = new D.Vector3();
        s.crossVectors(t, e);
        var o = new D.Matrix4();
        o.set(t.x, e.x, s.x, 0, t.y, e.y, s.y, 0, t.z, e.z, s.z, 0, 0, 0, 0, 1);
        var n = new D.Matrix4();
        n.getInverse(o);
        var h = new D.Vector3().subVectors(r, i);
        return h.applyMatrix4(n), {
            u: h.x,
            v: h.y
        };
    };
    var gt = vt, yt = function(t, e, i, r, s, o) {
        Y.call(this), this.tmpVect = new D.Vector3(), this.min_thick = s, this.max_thick = o, 
        this.v = t, this.p0p1 = this.tmpVect.clone().subVectors(this.v[1].getPos(), this.v[0].getPos()), 
        this.p2p0 = this.tmpVect.clone().subVectors(this.v[0].getPos(), this.v[2].getPos()), 
        this.unit_normal = e, this.main_dir = i;
        var n = Math.abs(this.v[0].getThickness() - this.v[1].getThickness()), h = Math.abs(this.v[1].getThickness() - this.v[2].getThickness());
        this.equal_weights = n / Math.abs(this.v[0].getThickness() + this.v[1].getThickness()) < .001 && h / Math.abs(this.v[1].getThickness() + this.v[2].getThickness()) < .001, 
        this.segParams = r, this.segAttr = {
            p0_to_p: 0,
            p0_to_p_sqrnorm: 0,
            x_p_2D: 0,
            y_p_2D: 0,
            y_p_2DSq: 0,
            p_proj_x: 0
        };
        var a = this.tmpVect.clone().crossVectors(this.segParams[0].dir, this.unit_normal).normalize(), c = this.tmpVect.clone().crossVectors(this.segParams[1].dir, this.unit_normal).normalize(), p = this.tmpVect.clone().crossVectors(this.segParams[2].dir, this.unit_normal).normalize();
        this.tmpVect.copy(this.unit_normal);
        var l = [];
        l.push(this.tmpVect.clone().addVectors(this.v[0].getPos(), this.tmpVect.multiplyScalar(this.v[0].getThickness() * K.KS))), 
        this.tmpVect.copy(this.unit_normal), l.push(this.tmpVect.clone().addVectors(this.v[1].getPos(), this.tmpVect.multiplyScalar(this.v[1].getThickness() * K.KS))), 
        this.tmpVect.copy(this.unit_normal), l.push(this.tmpVect.clone().addVectors(this.v[2].getPos(), this.tmpVect.multiplyScalar(this.v[2].getThickness() * K.KS))), 
        this.tmpVect.copy(this.unit_normal), l.push(this.tmpVect.clone().addVectors(this.v[0].getPos(), this.tmpVect.multiplyScalar(-this.v[0].getThickness() * K.KS))), 
        this.tmpVect.copy(this.unit_normal), l.push(this.tmpVect.clone().addVectors(this.v[1].getPos(), this.tmpVect.multiplyScalar(-this.v[1].getThickness() * K.KS))), 
        this.tmpVect.copy(this.unit_normal), l.push(this.tmpVect.clone().addVectors(this.v[2].getPos(), this.tmpVect.multiplyScalar(-this.v[2].getThickness() * K.KS)));
        var u = new D.Vector3();
        this.tmpVect.subVectors(l[1], l[0]), u.subVectors(l[2], l[0]);
        var _ = this.tmpVect.clone().crossVectors(this.tmpVect, u).normalize();
        this.tmpVect.subVectors(l[5], l[3]), u.subVectors(l[4], l[3]);
        var v = this.tmpVect.clone().crossVectors(this.tmpVect, u).normalize();
        this.planeParams = [], this.planeParams.push({
            orig: this.v[0].getPos(),
            n: a
        }), this.planeParams.push({
            orig: this.v[1].getPos(),
            n: c
        }), this.planeParams.push({
            orig: this.v[2].getPos(),
            n: p
        }), this.planeParams.push({
            orig: l[0],
            n: _
        }), this.planeParams.push({
            orig: l[3],
            n: v
        }), this.segAreas = [];
        for (var m = 0; m < 3; ++m) this.segAreas.push(new pt(this.segParams[m].v[0].getPos(), this.segParams[m].v[1].getPos(), this.segParams[m].v[0].getThickness(), this.segParams[m].v[1].getThickness(), this.segParams[m].norm, this.segParams[m].dir));
    };
    ((yt.prototype = Object.create(Y.prototype)).constructor = yt).prototype.proj_computation = function(t, e) {
        this.segAttr.p0_to_p = this.tmpVect, this.segAttr.p0_to_p.subVectors(t, e.v[0].getPos()), 
        this.segAttr.p0_to_p_sqrnorm = this.segAttr.p0_to_p.lengthSq(), this.segAttr.x_p_2D = this.segAttr.p0_to_p.dot(e.dir), 
        this.segAttr.y_p_2DSq = this.segAttr.p0_to_p_sqrnorm - this.segAttr.x_p_2D * this.segAttr.x_p_2D, 
        this.segAttr.y_p_2D = 0 < this.segAttr.y_p_2DSq ? Math.sqrt(this.segAttr.y_p_2DSq) : 0;
        var i = -this.segAttr.y_p_2D / e.ortho_vec_y;
        this.segAttr.p_proj_x = this.segAttr.x_p_2D + i * e.ortho_vec_x;
    }, yt.prototype.sphereIntersect = function(t) {
        for (var e = 0; e < 3; e++) {
            if (this.sphereIntersectSegment(t, this.segParams[e], K.KS)) return !0;
        }
        e = 0;
        for (var i = !0; e < 5; e++) {
            this.tmpVect.subVectors(t.center, this.planeParams[e].orig);
            var r = this.tmpVect.dot(this.planeParams[e].n);
            i = i && 0 < r + t.r;
        }
        return i;
    }, yt.prototype.sphereIntersectSegment = function(t, e, i) {
        this.proj_computation(t.center, e);
        var r = e.v[0].getThickness(), s = e.v[1].getThickness();
        if (this.segAttr.p_proj_x < 0) return Math.sqrt(this.segAttr.p0_to_p_sqrnorm) - t.r < r * i;
        if (this.segAttr.p_proj_x > e.norm) return this.segAttr.p0_to_p.subVectors(t.center, e.v[1].getPos()), 
        this.segAttr.p0_to_p.length() - t.r < s * i;
        var o = this.segAttr.x_p_2D - this.segAttr.p_proj_x, n = o * o + this.segAttr.y_p_2DSq, h = this.segAttr.p_proj_x / e.norm, a = r * (1 - h) + h * s, c = t.r + a * i;
        return n < c * c;
    }, yt.prototype.contains = function(t) {
        var e = {
            r: 0,
            c: t
        };
        return this.sphereIntersect(e);
    }, yt.prototype.getAccSegment = function(t, e) {
        var i = {
            intersect: !1,
            currAcc: tt.nice * this.min_thick
        };
        if (this.sphereIntersectSegment(t, e, 1)) {
            var r = Math.abs(e.diffThick) / e.norm, s = t.r * Math.sqrt(1 + r * r) * .5, o = e.v[0].getThickness(), n = e.v[1].getThickness(), h = this.segAttr.p_proj_x;
            if ((h += n < o ? s : -s) <= 0) i.currAcc = o; else if (h >= e.norm) i.currAcc = n; else {
                var a = h / e.norm;
                i.currAcc = o * (1 - a) + a * n;
            }
            i.intersect = !0;
        }
        return i;
    }, yt.prototype.getAccTri = function(t) {
        if (this.equal_weights) return this.min_thick;
        var e = this.v[0].getPos(), i = this.tmpVect.addVectors(t.center, this.main_dir.clone().multiplyScalar(t.r));
        this.tmpVect.subVectors(i, e);
        var r = this.tmpVect.lengthSq(), s = this.tmpVect.dot(this.unit_normal), o = Math.sqrt(r - s * s), n = this.tmpVect.clone().addVectors(t.center, this.unit_normal.clone().multiplyScalar(-s)), h = gt.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), n), a = gt.getMeanThick(this, h.u, h.v);
        a = 0 <= s ? a : -a;
        var c = o + -s / o * (this.v[0].getThickness() - a), p = this.tmpVect.subVectors(e, n).normalize(), l = this.tmpVect.addVectors(n, p.multiplyScalar(o - c));
        return (h = gt.getTriBaryCoord(this.p0p1, this.p2p0, this.v[0].getPos(), l)).u <= 1 && h.v <= 1 && h.u + h.v <= 1 && 0 <= h.u && 0 <= h.v ? gt.getMeanThick(this, h.u, h.v) : 1e4 * this.max_thick;
    }, yt.prototype.getAcc = function(t, e) {
        for (var i = 0, r = 1e5 * this.max_thick; i < 3; i++) {
            var s = this.getAccSegment(t, this.segParams[i]);
            s.intersect && (r = r > s.currAcc ? s.currAcc : r);
        }
        var o = 1e5 * this.max_thick;
        r !== this.min_thick && (o = this.getAccTri(t));
        var n = Math.min(r, o);
        return n !== 1e5 * this.max_thick ? n * e : this.max_thick * e;
    }, yt.prototype.getNiceAcc = function(t) {
        return this.getAcc(t, tt.nice);
    }, yt.prototype.getCurrAcc = function(t) {
        return this.getAcc(t, tt.curr);
    }, yt.prototype.getRawAcc = function(t) {
        return this.getAcc(t, tt.raw);
    }, yt.prototype.getMinAcc = function() {
        return tt.curr * this.min_thick;
    }, yt.prototype.getMinRawAcc = function() {
        return tt.raw * this.min_thick;
    }, yt.prototype.getAxisProjectionMinStep = function(t, e) {
        for (var i = Number.MAX_VALUE, r = 0; r < 3; ++r) i = Math.min(i, this.segAreas[r].getAxisProjectionMinStep(t, e));
        return i;
    };
    var dt, ft, bt, wt, xt, Vt, At, St, Mt, Tt, Bt, Pt, kt = yt, Ft = function(t, e, i, r) {
        if (H.call(this), 1 !== i) throw "Error in ScalisTriangle : cannot use a density different from 1.0, not implemented.";
        this.volType = e, this.materials = null !== r ? r : [ _.defaultMaterial.clone(), _.defaultMaterial.clone(), _.defaultMaterial.clone() ], 
        this.v = t, this.v[0].setPrimitive(this), this.v[1].setPrimitive(this), this.v[2].setPrimitive(this), 
        this.min_thick = Math.min(this.v[0].getThickness(), this.v[1].getThickness(), this.v[2].getThickness()), 
        this.max_thick = Math.max(this.v[0].getThickness(), this.v[1].getThickness(), this.v[2].getThickness()), 
        this.res_gseg = {}, this.tmp_res_gseg = {}, this.p0p1 = new D.Vector3(), this.p1p2 = new D.Vector3(), 
        this.p2p0 = new D.Vector3(), this.unit_normal = new D.Vector3(), this.unit_p0p1 = new D.Vector3(), 
        this.unit_p1p2 = new D.Vector3(), this.unit_p2p0 = new D.Vector3(), this.length_p0p1 = 0, 
        this.length_p1p2 = 0, this.length_p2p0 = 0, this.diffThick_p0p1 = 0, this.diffThick_p0p1 = 0, 
        this.diffThick_p0p1 = 0, this.main_dir = new D.Vector3(), this.point_iso_zero = new D.Vector3(), 
        this.ortho_dir = new D.Vector3(), this.unsigned_ortho_dir = new D.Vector3(), this.proj_dir = new D.Vector3(), 
        this.equal_weights = !1, this.coord_max = 0, this.coord_middle = 0, this.unit_delta_weight = 0, 
        this.longest_dir_special = 0, this.max_seg_length = 0, this.half_dir_1 = new D.Vector3(), 
        this.point_half = new D.Vector3(), this.half_dir_2 = new D.Vector3(), this.point_min = new D.Vector3(), 
        this.weight_min = 0, this.valid_aabb = !1;
    };
    ((Ft.prototype = Object.create(H.prototype)).constructor = Ft).type = "ScalisTriangle", 
    r.register(Ft.type, Ft), Ft.prototype.getType = function() {
        return Ft.type;
    }, Ft.prototype.toJSON = function() {
        return H.prototype.toJSON.call(this);
    }, Ft.fromJSON = function(t) {
        var e = [ W.fromJSON(t.v[0]), W.fromJSON(t.v[1]), W.fromJSON(t.v[2]) ], i = [ _.fromJSON(t.materials[0]), _.fromJSON(t.materials[1]), _.fromJSON(t.materials[2]) ];
        return new Ft(e, t.volType, i);
    }, Ft.prototype.prepareForEval = function() {
        this.valid_aabb || (this.computeHelpVariables(), this.valid_aabb = !0);
    }, Ft.prototype.getAreas = function() {
        if (this.valid_aabb) {
            var t = [];
            return t.push({
                norm: this.length_p0p1,
                diffThick: this.diffThick_p0p1,
                dir: this.unit_p0p1,
                v: [ this.v[0], this.v[1] ],
                ortho_vec_x: this.v[0].getThickness() - this.v[1].getThickness(),
                ortho_vec_y: this.length_p0p1
            }), t.push({
                norm: this.length_p1p2,
                diffThick: this.diffThick_p1p2,
                dir: this.unit_p1p2,
                v: [ this.v[1], this.v[2] ],
                ortho_vec_x: this.v[1].getThickness() - this.v[2].getThickness(),
                ortho_vec_y: this.length_p1p2
            }), t.push({
                norm: this.length_p2p0,
                diffThick: this.diffThick_p2p0,
                dir: this.unit_p2p0,
                v: [ this.v[2], this.v[0] ],
                ortho_vec_x: this.v[2].getThickness() - this.v[0].getThickness(),
                ortho_vec_y: this.length_p2p0
            }), [ {
                aabb: this.aabb,
                bv: new kt(this.v, this.unit_normal, this.main_dir, t, this.min_thick, this.max_thick),
                obj: this
            } ];
        }
        return console.log("ERROR : Cannot get area of invalid primitive"), [];
    }, Ft.prototype.computeHelpVariables = function() {
        gt.computeVectorsDirs(this), this.computeAABB();
    }, Ft.prototype.mutableVolType = function() {
        return !0;
    }, Ft.prototype.setVolType = function(t) {
        if (t != H.CONVOL && t != H.DIST) throw "ERROR : volType must be set to ScalisPrimitive.CONVOL or ScalisPrimitive.DIST";
        this.volType != t && (this.volType = t, this.invalidAABB());
    }, Ft.prototype.getVolType = function() {
        return this.volType;
    }, Ft.prototype.clamp = function(t, e, i) {
        return Math.max(e, Math.min(i, t));
    }, Ft.prototype.distanceTo = (dt = new D.Vector3(), ft = new D.Vector3(), bt = new D.Vector3(), 
    wt = new D.Vector3(), function(t) {
        if (dt.subVectors(t, this.v[0].getPos()), ft.subVectors(t, this.v[1].getPos()), 
        bt.subVectors(t, this.v[2].getPos()), 0 < wt.crossVectors(this.p0p1, dt).dot(this.unit_normal) && 0 < wt.crossVectors(this.p1p2, ft).dot(this.unit_normal) && 0 < wt.crossVectors(this.p2p0, bt).dot(this.unit_normal)) return Math.abs(dt.dot(this.unit_normal));
        var e = dt.dot(this.p0p1) / this.length_p0p1;
        e = this.clamp(e, 0, 1), wt.copy(this.p0p1).multiplyScalar(e).add(this.v[0].getPos()), 
        e = t.distanceToSquared(wt);
        var i = ft.dot(this.p1p2) / this.length_p1p2;
        i = this.clamp(i, 0, 1), wt.copy(this.p1p2).multiplyScalar(i).add(this.v[1].getPos()), 
        i = t.distanceToSquared(wt);
        var r = bt.dot(this.p2p0) / this.length_p2p0;
        return r = this.clamp(r, 0, 1), wt.copy(this.p2p0).multiplyScalar(r).add(this.v[2].getPos()), 
        r = t.distanceToSquared(wt), Math.sqrt(Math.min(Math.min(e, i), r));
    }), Ft.prototype.heuristicStepWithin = function() {
        return this.weight_min / 3;
    }, Ft.prototype.value = function(t, e) {
        switch (this.volType) {
          case H.DIST:
            return this.evalDist(t, e);

          case H.CONVOL:
            return this.evalConvol(t, e);

          default:
            throw "Unknown volType, use Orga";
        }
    }, Ft.prototype.evalDist = (xt = {
        v: 0
    }, Vt = new D.Vector3(), function(t, e) {
        var i = new D.Vector3();
        i.subVectors(t, this.v[0].getPos());
        var r = this.unit_normal.clone().multiplyScalar(-1);
        if (!this.equal_weights) {
            var s = r, o = this.unsigned_ortho_dir, n = this.main_dir.clone().multiplyScalar(-1), h = -this.v[0].getPos().dot(s), a = -t.dot(o), c = -this.point_iso_zero.dot(n), p = new D.Vector3();
            p.crossVectors(o, n), p.multiplyScalar(-h);
            var l = new D.Vector3();
            l.crossVectors(n, s), l.multiplyScalar(-a);
            var u = new D.Vector3();
            u.crossVectors(s, o), u.multiplyScalar(-c);
            var _ = new D.Vector3();
            _.crossVectors(o, n);
            var v = new D.Vector3(p.x + l.x + u.x, p.y + l.y + u.y, p.z + l.z + u.z);
            v.divideScalar(s.dot(_));
            var m = new D.Vector3(v.x - t.x, v.y - t.y, v.z - t.z);
            this.proj_dir = new D.Vector3(), this.proj_dir.crossVectors(m, this.unsigned_ortho_dir), 
            this.proj_dir.normalize();
        }
        var g = new D.Vector3();
        g.copy(this.proj_dir), g.multiplyScalar(-i.dot(r) / this.proj_dir.dot(r)), g.add(t);
        var y = new D.Vector3(), d = new D.Vector3(), f = new D.Vector3(), b = new D.Vector3();
        if (d.subVectors(g, this.v[0].getPos()), f.subVectors(g, this.v[1].getPos()), b.subVectors(g, this.v[2].getPos()), 
        0 < y.crossVectors(this.unit_p0p1, d).dot(r) && 0 < y.crossVectors(this.unit_p1p2, f).dot(r) && 0 < y.crossVectors(this.unit_p2p0, b).dot(r)) {
            y.subVectors(t, g), e.v = y.lengthSq();
            var w = this.v[0].getPos(), x = this.v[1].getPos(), V = this.v[2].getPos(), A = new D.Vector3();
            y.subVectors(x, w), A.subVectors(V, w);
            var S = new D.Vector3();
            S.crossVectors(y, A), y.subVectors(V, x), (s = new D.Vector3()).crossVectors(y, f), 
            y.subVectors(w, V), (o = new D.Vector3()).crossVectors(y, b), y.subVectors(x, w), 
            (n = new D.Vector3()).crossVectors(y, d);
            var M = S.lengthSq(), T = S.dot(s), B = S.dot(o), P = S.dot(n), k = (T * this.v[0].getThickness() + B * this.v[1].getThickness() + P * this.v[2].getThickness()) / M;
            e.v = K.Poly6Eval(Math.sqrt(e.v) / k) * K.Poly6NF0D, e.m && e.m.triMean(this.materials[0], this.materials[1], this.materials[2], T, B, P, M);
        } else {
            var F = 0;
            if (this.GenericSegmentComputation(t, this.v[0].getPos(), this.p0p1, this.length_p0p1, this.length_p0p1 * this.length_p0p1, this.v[0].getThickness(), this.v[1].getThickness() - this.v[0].getThickness(), this.res_gseg), 
            this.res_gseg.sqrdist = this.res_gseg.proj_to_p.lengthSq(), this.res_gseg.ratio = this.res_gseg.sqrdist / (this.res_gseg.weight_proj * this.res_gseg.weight_proj), 
            this.GenericSegmentComputation(t, this.v[1].getPos(), this.p1p2, this.length_p1p2, this.length_p1p2 * this.length_p1p2, this.v[1].getThickness(), this.v[2].getThickness() - this.v[1].getThickness(), this.tmp_res_gseg), 
            this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq(), this.tmp_res_gseg.ratio = this.tmp_res_gseg.sqrdist / (this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj), 
            this.res_gseg.ratio > this.tmp_res_gseg.ratio && (this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist, 
            this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p, this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj, 
            this.res_gseg.ratio = this.tmp_res_gseg.ratio, this.res_gseg.t = this.tmp_res_gseg.t, 
            F = 1), this.GenericSegmentComputation(t, this.v[2].getPos(), this.p2p0, this.length_p2p0, this.length_p2p0 * this.length_p2p0, this.v[2].getThickness(), this.v[0].getThickness() - this.v[2].getThickness(), this.tmp_res_gseg), 
            this.tmp_res_gseg.sqrdist = this.tmp_res_gseg.proj_to_p.lengthSq(), this.tmp_res_gseg.ratio = this.tmp_res_gseg.sqrdist / (this.tmp_res_gseg.weight_proj * this.tmp_res_gseg.weight_proj), 
            this.res_gseg.ratio > this.tmp_res_gseg.ratio && (this.res_gseg.sqrdist = this.tmp_res_gseg.sqrdist, 
            this.res_gseg.proj_to_p = this.tmp_res_gseg.proj_to_p, this.res_gseg.weight_proj = this.tmp_res_gseg.weight_proj, 
            this.res_gseg.ratio = this.tmp_res_gseg.ratio, this.res_gseg.t = this.tmp_res_gseg.t, 
            F = 2), e.v = K.Poly6Eval(Math.sqrt(this.res_gseg.sqrdist) / this.res_gseg.weight_proj) * K.Poly6NF0D, 
            e.m) switch (F) {
              case 0:
                e.m.copy(this.materials[0]), e.m.lerp(this.materials[1], this.res_gseg.t);
                break;

              case 1:
                e.m.copy(this.materials[1]), e.m.lerp(this.materials[2], this.res_gseg.t);
                break;

              case 2:
                e.m.copy(this.materials[2]), e.m.lerp(this.materials[0], this.res_gseg.t);
                break;

              default:
                throw "Error : seg_case unknown";
            }
        }
        if (e.g) {
            var N = 1e-5;
            Vt.copy(t), Vt.x += N, this.evalDist(Vt, xt), e.g.x = (xt.v - e.v) / N, Vt.x -= N, 
            Vt.y += N, this.evalDist(Vt, xt), e.g.y = (xt.v - e.v) / N, Vt.y -= N, Vt.z += N, 
            this.evalDist(Vt, xt), e.g.z = (xt.v - e.v) / N;
        }
    }), Ft.prototype.GenericSegmentComputation = function(t, e, i, r, s, o, n, h) {
        var a = new D.Vector3();
        a.subVectors(t, e);
        var c = a.dot(i), p = a.lengthSq(), l = s * o + c * n, u = n < 0 ? 0 : 1;
        return 0 < l && (u = (u = (c * o + p * n) / l) < 0 ? 0 : 1 < u ? 1 : u), h.proj_to_p = new D.Vector3(u * i.x - a.x, u * i.y - a.y, u * i.z - a.z), 
        h.weight_proj = o + u * n, h.t = u, h;
    }, Ft.prototype.evalConvol = (At = new D.Vector3(), St = new _(null, null, null), 
    Mt = {
        v: 0,
        g: null,
        m: null
    }, Tt = new D.Vector3(), Bt = new _(null, null, null), Pt = {
        v: 0,
        g: null,
        m: null
    }, function(t, e) {
        Mt.g = e.g ? At : null, Mt.m = e.m ? St : null;
        var i = {
            l1: 0,
            l2: 0
        };
        if (this.ComputeTParam(t, i)) {
            var r = i.l1, s = i.l2, o = this.weight_min + r * this.unit_delta_weight, n = this.warpAbscissa((s - r) / o), h = 2 * (5 * n + 1), a = n / h, c = a;
            a *= 2;
            for (var p = 0, l = new D.Vector3(), u = 1; u < h; u += 2) this.computeLineIntegral(this.unwarpAbscissa(c) * o + r, t, Mt), 
            p += Mt.v, e.g && l.addVectors(l, Mt.g), c += a;
            var _ = 0, v = new D.Vector3();
            for (c = 0, u = 2; u < h; u += 2) c += a, this.computeLineIntegral(this.unwarpAbscissa(c) * o + r, t, Mt), 
            e.g && v.addVectors(v, Mt.g), _ += Mt.v;
            Pt.g = e.g ? Tt : null, Pt.m = e.m ? Bt : null;
            var m = this.computeLineIntegral(r, t, Mt), g = this.computeLineIntegral(s, t, Pt);
            e.v = m.v + 4 * p + 2 * _ + m.v;
            var y = n / (3 * h) * K.Poly6NF2D;
            if (e.v *= y, e.g) {
                var d = new D.Vector3();
                d.addVectors(d, m.g), d.addVectors(d, l.multiplyScalar(4)), d.addVectors(d, v.multiplyScalar(2)), 
                d.addVectors(d, g.g), e.g = d.multiplyScalar(y);
            }
        } else e.v = 0, e.g = new D.Vector3();
        e.m && (Mt.g = null, this.evalDist(t, Mt), e.m.copy(Mt.m));
    }), Ft.prototype.warpAbscissa = function(t) {
        var e = t * this.unit_delta_weight, i = 1 / (e + 2), r = e * i;
        return 2 * t * i * (1 + (r *= r) * (1 / 3 + r * (.2 + r * (1 / 7 + r * (1 / 9 + r * (1 / 11 + r * (1 / 13)))))));
    }, Ft.prototype.unwarpAbscissa = function(t) {
        var e = t * this.unit_delta_weight;
        return t * (1 + e * (.5 + e * (1 / 6 + e * (1 / 24 + e * (1 / 120 + 1 * e / 720)))));
    }, Ft.prototype.computeLineIntegral = function(t, e, i) {
        var r = this.weight_min + t * this.unit_delta_weight, s = new D.Vector3();
        s.addVectors(this.point_min, this.longest_dir_special.clone().multiplyScalar(t));
        var o = t < this.coord_middle ? t / this.coord_middle * this.max_seg_length : (this.coord_max - t) / (this.coord_max - this.coord_middle) * this.max_seg_length;
        return i.g ? this.consWeightEvalGradForSeg(s, r, this.ortho_dir, o, e, i) : this.consWeightEvalForSeg(s, r, this.ortho_dir, o, e, i), 
        i;
    }, Ft.prototype.homotheticClippingSpecial = function(t, e, i) {
        var r = -t.z, s = -t.y, o = -t.x, n = s * s - r * o;
        if (0 <= n) {
            var h = s + Math.sqrt(n);
            if (h < 0 || e * h < o) return !1;
            var a = o / h;
            i.l1 = a < 0 ? 0 : a;
            var c = r * a;
            return i.l2 = 2 * s < c + r * e ? o / c : e, !0;
        }
        return !1;
    }, Ft.prototype.consWeightEvalForSeg = function(t, e, i, r, s, o) {
        var n = new D.Vector3();
        n.subVectors(s, t);
        var h = i.dot(n), a = n.lengthSq(), c = new D.Vector3();
        c.set(e * e - K.KIS2 * a, -K.KIS2 * h, -K.KIS2);
        var p = {
            l1: 0,
            l2: 0
        };
        if (this.homotheticClippingSpecial(c, r, p)) {
            var l = 1 / e;
            c.x = 1 - K.KIS2 * (p.l1 * (p.l1 - 2 * h) + a) * l * l, c.y = -K.KIS2 * (h - p.l1) * l, 
            o.v = this.homotheticCompactPolynomial_segment_F_i6_cste((p.l2 - p.l1) * l, c);
        } else o = 0;
        return o;
    }, Ft.prototype.consWeightEvalGradForSeg = function(t, e, i, r, s, o) {
        var n = new D.Vector3();
        n.subVectors(s, t);
        var h = i.dot(n), a = n.lengthSq(), c = new D.Vector3();
        c.set(e * e - K.KIS2 * a, -K.KIS2 * h, -K.KIS2);
        var p = {
            l1: 0,
            l2: 0
        };
        if (this.homotheticClippingSpecial(c, r, p)) {
            var l = 1 / e;
            c.x = 1 - K.KIS2 * (p.l1 * (p.l1 - 2 * h) + a) * l * l, c.y = -K.KIS2 * (h - p.l1) * l;
            var u = new D.Vector3();
            this.homotheticCompactPolynomial_segment_FGradF_i6_cste((p.l2 - p.l1) * l, c, u), 
            o.v = u.x, u.y *= l;
            var _ = i.clone();
            _.multiplyScalar(u.z + p.l1 * u.y), n.multiplyScalar(-u.y), n.addVectors(n, _), 
            o.g = n.multiplyScalar(6 * K.KIS2 * l);
        } else o.v = 0, o.g.set(0, 0, 0);
        return o;
    }, Ft.prototype.ComputeTParam = function(t, e) {
        var i = new D.Vector3();
        i.subVectors(t, this.point_min);
        var r = i.dot(this.main_dir), s = i.dot(this.unit_normal), o = r * r + s * s, n = new D.Vector3();
        return n.set(this.weight_min * this.weight_min - K.KIS2 * o, -this.unit_delta_weight * this.weight_min - K.KIS2 * r, this.unit_delta_weight * this.unit_delta_weight - K.KIS2), 
        this.homotheticClippingSpecial(n, this.coord_max, e);
    }, Ft.prototype.homotheticCompactPolynomial_segment_F_i6_cste = function(t, e) {
        var i = e.z, r = i * t, s = e.y, o = e.x, n = i * o - s * s, h = 1 / i, a = n * h, c = o + (-2 * s + r) * t, p = r - s, l = p * (c * c), u = s * (o * o);
        return (1.2 * (4 / 3 * (2 * n * t + p * c + s * o) * a + l + u) * a + c * l + o * u) * h / 7;
    }, Ft.prototype.homotheticCompactPolynomial_segment_FGradF_i6_cste = function(t, e, i) {
        var r = e.z, s = r * t, o = e.y, n = e.x, h = r * n - o * o, a = 1 / r, c = h * a, p = n + (-2 * o + s) * t, l = s - o, u = p * p, _ = n * n, v = 4 / 3 * (2 * h * t + l * p + o * n) * c + l * u + o * _, m = v * a / 5, g = n * _, y = p * u;
        i.x = (1.2 * v * c + l * y + o * g) * a / 7, i.y = m, i.z = (o * m + y / 6 - g / 6) * a;
    };
    var Nt = Ft, Dt = function() {};
    (Dt.prototype.constructor = Dt).type = "DistanceFunctor", r.register(Dt.type, Dt), 
    Dt.prototype.getType = function() {
        return Dt.type;
    }, Dt.prototype.toJSON = function() {
        return {
            type: this.getType()
        };
    }, Dt.prototype.fromJSON = function(t) {
        return r.fromJSON(t);
    }, Dt.prototype.value = function(t) {
        throw "Error : not implemented. Must be reimplemented in children classes.";
    }, Dt.prototype.value = function(t) {
        throw "Error : not implemented. Must be reimplemented in children classes.";
    }, Dt.prototype.numericalGradient = function(t, e) {
        var i = e || 1e-5;
        return (this.value(t + i) - this.value(t - i)) / (2 * i);
    }, Dt.prototype.gradient = function(t) {
        return this.numericalGradient(t, 1e-5);
    }, Dt.prototype.getSupport = function(t) {
        return 1 / 0;
    };
    var zt = Dt, Ot = function(t) {
        this.scale = t || 1;
    };
    ((Ot.prototype = Object.create(zt.prototype)).constructor = Ot).type = "Poly6DistanceFunctor", 
    r.register(Ot.type, Ot), Ot.prototype.getType = function() {
        return Ot.type;
    }, Ot.prototype.toJSON = function() {
        var t = Blobtree.DistanceFunctor.prototype.toJSON.call(this, c);
        return t.scale = this.scale, t;
    }, Ot.evalStandard = function(t) {
        if (t < 0) return 1;
        var e = 1 - t * t;
        return 0 < e ? e * e * e : 0;
    }, Ot.prototype.value = function(t) {
        var e = t / (2 * this.scale);
        return Ot.evalStandard(e += .5) / Ot.evalStandard(.5);
    }, Ot.prototype.gradient = function(t) {
        var e = t / (2 * this.scale) + .5, i = 1 - e * e;
        return i = -6 / (2 * this.scale) * e * i * i / Ot.evalStandard(.5);
    }, Ot.prototype.getSupport = function(t) {
        return this.scale;
    };
    var Et = Ot, qt = function() {
        a.call(this), this.aabb.set(new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0), new THREE.Vector3(1 / 0, 1 / 0, 1 / 0));
    };
    ((qt.prototype = Object.create(a.prototype)).constructor = qt).type = "SDFNode", 
    r.register(qt.type, qt), qt.prototype.getType = function() {
        return qt.type;
    }, qt.prototype.computeAABB = function() {}, qt.prototype.computeDistanceAABB = function(t) {
        throw "computeDistanceAABB is an abstract function of SDFNode. Please reimplement it in children classes.";
    }, qt.prototype.getAreas = function() {
        throw "No Areas for SDFNode, except for the SDFRootNode.";
    }, qt.prototype.distanceTo = function(t) {
        throw "distanceTo should be reimplemented in every children classes of SDFNode.";
    }, qt.prototype.heuristicStepWithin = function() {
        throw "heuristicStepWithin may not make sens for all SDFNode, except for the SDFRootNode.";
    };
    var jt = qt, Rt = function(t, e, i) {
        jt.call(this), this.f = t, this.material = e ? e.clone() : new _(null, null, null), 
        this.addChild(i), this.tmp_res = {
            v: 0,
            g: null
        }, this.tmp_g = new D.Vector3(0, 0, 0);
    };
    ((Rt.prototype = Object.create(jt.prototype)).constructor = Rt).type = "SDFRootNode", 
    r.register(Rt.type, Rt), Rt.prototype.getType = function() {
        return Rt.type;
    }, Rt.prototype.addChild = function(t) {
        if (0 !== this.children.length) throw "Error : SDFRootNode can have only one child.";
        jt.prototype.addChild.call(this, t);
    }, Rt.prototype.toJSON = function() {
        var t = jt.prototype.toJSON.call(this);
        return t.f = this.f.toJSON(), t;
    }, Rt.fromJSON = function(t) {
        var e = new Rt(r.fromJSON(e.f), r.fromJSON(t.children[0]));
        return e;
    }, Rt.prototype.prepareForEval = function() {
        if (!this.valid_aabb) {
            this.aabb = new D.Box3();
            for (var t = 0; t < this.children.length; ++t) {
                var e = this.children[t];
                e.prepareForEval(), this.aabb.union(e.computeDistanceAABB(this.f.getSupport()));
            }
            this.valid_aabb = !0;
        }
    }, Rt.prototype.getAreas = function() {
        if (this.valid_aabb) return this.children[0].getAreas(this.f.getSupport());
        throw "ERROR : Cannot get area of invalid node";
    }, Rt.prototype.value = function(t, e) {
        var i = this.tmp_res;
        i.g = e.g ? this.tmp_g : null, e.v = 0, e.m && e.m.copy(_.defaultMaterial), e.g || e.step && (e.step = 1e9), 
        this.aabb.containsPoint(t) ? (this.children[0].value(t, i), e.v = this.f.value(i.v), 
        e.g && e.g.copy(i.g).multiplyScalar(this.f.gradient(e.v)), e.m && e.m.copy(this.material)) : e.step && (e.step = this.aabb.distanceToPoint(t) + .3);
    };
    var Ct, It = Rt, Jt = function() {
        s.call(this), this.aabb.set(new THREE.Vector3(-1 / 0, -1 / 0, -1 / 0), new THREE.Vector3(1 / 0, 1 / 0, 1 / 0));
    };
    ((Jt.prototype = Object.create(s.prototype)).constructor = Jt).type = "SDFPrimitive", 
    r.register(Jt.type, Jt), Jt.prototype.SDFPrimitive = function() {
        return Jt.type;
    }, Jt.prototype.computeAABB = function() {}, Jt.prototype.computeDistanceAABB = function(t) {
        throw "computeDistanceAABB is an abstract function of SDFPrimitive. Please reimplement it in children classes.";
    }, Jt.prototype.getAreas = function() {
        throw "No Areas for SDFPrimitive.";
    }, Jt.prototype.distanceTo = (Ct = {
        v: 0
    }, function(t) {
        return this.value(t, Ct), Ct.v;
    }), Jt.prototype.heuristicStepWithin = function() {
        throw "Not implemented";
    };
    var Kt, Gt = Jt, Ht = function(t, e) {
        Gt.call(this), this.p = t.clone(), this.acc = e || 1;
    };
    ((Ht.prototype = Object.create(Gt.prototype)).constructor = Ht).type = "SDFPoint", 
    r.register(Ht.type, Ht), Ht.prototype.getType = function() {
        return Ht.type;
    }, Ht.prototype.toJSON = function() {
        var t = Gt.prototype.toJSON.call(this);
        return t.p = {
            x: this.p.x,
            y: this.p.y,
            z: this.p.z
        }, t.acc = this.acc, t;
    }, Ht.fromJSON = function(t) {
        return new Ht(new D.Vector3(t.p.x, t.p.y, t.p.z), t.acc);
    }, Ht.prototype.setAccuracy = function(t) {
        this.acc = t, this.invalidAABB();
    }, Ht.prototype.getAccuracy = function() {
        return this.acc;
    }, Ht.prototype.setPosition = function(t) {
        this.p.copy(t), this.invalidAABB();
    }, Ht.prototype.getPosition = function() {
        return this.p;
    }, Ht.prototype.computeDistanceAABB = function(t) {
        return new D.Box3(this.p.clone().add(new D.Vector3(-t, -t, -t)), this.p.clone().add(new D.Vector3(t, t, t)));
    }, Ht.prototype.prepareForEval = function() {
        this.valid_aabb || (this.valid_aabb = !0);
    }, Ht.prototype.getAreas = function(t) {
        if (this.valid_aabb) return [ {
            aabb: this.computeDistanceAABB(t),
            bv: new it(this.p, t, this.acc),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, Ht.prototype.value = (Kt = new D.Vector3(), function(t, e) {
        if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
        Kt.subVectors(t, this.p);
        var i = Kt.length();
        e.v = i, e.g && e.g.copy(Kt).multiplyScalar(1 / i);
    });
    var Lt = Ht, Ut = function(t, e, i, r, s, o) {
        Y.call(this), this.p1 = t.clone(), this.p2 = e.clone(), this.r1 = i, this.r2 = r, 
        this.accFactor1 = s || 1, this.accFactor2 = o || 1, this.unit_dir = new D.Vector3().subVectors(e, t), 
        this.length = this.unit_dir.length(), this.unit_dir.normalize(), this.vector = new D.Vector3(), 
        this.p1_to_p = this.vector, this.p1_to_p_sqrnorm = 0, this.x_p_2D = 0, this.y_p_2D = 0, 
        this.y_p_2DSq = 0, this.ortho_vec_x = this.r1 - this.r2, this.ortho_vec_y = this.length, 
        this.p_proj_x = 0, this.p_proj_y = 0, this.abs_diff_thick = Math.abs(this.ortho_vec_x);
    };
    ((Ut.prototype = Object.create(Y.prototype)).constructor = Ut).prototype.proj_computation = function(t) {
        this.p1_to_p = this.vector, this.p1_to_p.subVectors(t, this.p1), this.p1_to_p_sqrnorm = this.p1_to_p.lengthSq(), 
        this.x_p_2D = this.p1_to_p.dot(this.unit_dir), this.y_p_2DSq = this.p1_to_p_sqrnorm - this.x_p_2D * this.x_p_2D, 
        this.y_p_2D = 0 < this.y_p_2DSq ? Math.sqrt(this.y_p_2DSq) : 0;
        var e = -this.y_p_2D / this.ortho_vec_y;
        this.p_proj_x = this.x_p_2D + e * this.ortho_vec_x, this.p_proj_y = 0;
    }, Ut.prototype.sphereIntersect = function(t) {
        if (this.proj_computation(t.center), this.p_proj_x < 0) return Math.sqrt(this.p1_to_p_sqrnorm) - t.radius < this.r1;
        if (this.p_proj_x > this.length) return this.vector.subVectors(t.center, this.p2), 
        Math.sqrt(this.vector.lengthSq()) - t.radius < this.r2;
        var e = this.x_p_2D - this.p_proj_x, i = e * e + this.y_p_2DSq, r = this.p_proj_x / this.length, s = this.r1 * (1 - r) + r * this.r2, o = t.radius + s;
        return i < o * o;
    }, Ut.prototype.contains = function(t) {
        if (this.proj_computation(t), this.p_proj_x < 0) return this.p1_to_p_sqrnorm < this.r1 * this.r1;
        if (this.p_proj_x > this.length) return this.vector.subVectors(t, this.p2), this.vector.lengthSq() < this.r2 * this.r2;
        var e = this.x_p_2D - this.p_proj_x, i = this.y_p_2D - this.p_proj_y, r = e * e + i * i, s = this.p_proj_x / this.length, o = this.r1 * (1 - s) + s * this.r2;
        return r < o * o;
    }, Ut.prototype.getAcc = function(t, e) {
        this.proj_computation(t.center);
        var i = this.abs_diff_thick / this.length, r = t.radius * Math.sqrt(1 + i * i) * .5, s = this.p_proj_x;
        if ((s += this.r1 > this.r2 ? r : -r) < 0) return this.r1 * this.accFactor1 * e;
        if (s > this.length) return this.r2 * this.accFactor2 * e;
        var o = s / this.length;
        return (this.r1 * this.accFactor1 * (1 - o) + o * this.r2 * this.accFactor2) * e;
    }, Ut.prototype.getNiceAcc = function(t) {
        return this.getAcc(t, tt.nice);
    }, Ut.prototype.getCurrAcc = function(t) {
        return this.getAcc(t, tt.curr);
    }, Ut.prototype.getRawAcc = function(t) {
        return this.getAcc(t, tt.raw);
    }, Ut.prototype.getMinAcc = function() {
        return tt.curr * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
    }, Ut.prototype.getMinRawAcc = function() {
        return tt.raw * Math.min(this.r1 * this.accFactor1, this.r2 * this.accFactor2);
    }, Ut.prototype.getAxisProjectionMinStep = function(t, e) {
        var i, r, s, o = Number.MAX_VALUE, n = this.p1[t] < this.p2[t] ? this.p1 : this.p2;
        s = n === this.p1 ? (i = this.p2, r = this.r1 * this.accFactor1, this.r2 * this.accFactor2) : (i = this.p1, 
        r = this.r2, this.r1 * this.accFactor1);
        var h = e - n[t];
        h < -2 * r ? o = Math.min(o, Math.max(Math.abs(h + 2 * r), tt.curr * r)) : h < 2 * r && (o = Math.min(o, tt.curr * r)), 
        (h = e - i[t]) < -2 * s ? o = Math.min(o, Math.max(Math.abs(h + 2 * s), tt.curr * s)) : h < 2 * s && (o = Math.min(o, tt.curr * s));
        var a = e - n[t], c = i[t] - n[t];
        return 0 < a && a < c && 0 !== c && (o = Math.min(o, tt.curr * (r + a / c * (s - r)))), 
        o;
    };
    var Wt, Zt, Xt = Ut, Qt = function(t, e, i) {
        Gt.call(this), this.p1 = t.clone(), this.p2 = e.clone(), this.acc = i || 1, this.l = new D.Line3(this.p1, this.p2);
    };
    ((Qt.prototype = Object.create(Gt.prototype)).constructor = Qt).type = "SDFSegment", 
    r.register(Qt.type, Qt), Qt.prototype.getType = function() {
        return Qt.type;
    }, Qt.prototype.toJSON = function() {
        var t = Gt.prototype.toJSON.call(this);
        return t.p1 = {
            x: this.p1.x,
            y: this.p1.y,
            z: this.p1.z
        }, t.p2 = {
            x: this.p2.x,
            y: this.p2.y,
            z: this.p2.z
        }, t.acc = this.acc, t;
    }, Qt.fromJSON = function(t) {
        ScalisVertex.fromJSON(t.v[0]);
        return new Qt(new D.Vector3(t.p1.x, t.p1.y, t.p1.z), new D.Vector3(t.p2.x, t.p2.y, t.p2.z), t.acc);
    }, Qt.prototype.setAccuracy = function(t) {
        this.acc = t, this.invalidAABB();
    }, Qt.prototype.getAccuracy = function() {
        return this.acc;
    }, Qt.prototype.setPosition1 = function(t) {
        this.p1.copy(t), this.invalidAABB();
    }, Qt.prototype.setPosition2 = function(t) {
        this.p2.copy(t), this.invalidAABB();
    }, Qt.prototype.getPosition1 = function() {
        return this.p1;
    }, Qt.prototype.getPosition2 = function() {
        return this.p2;
    }, Qt.prototype.computeDistanceAABB = function(t) {
        var e = new D.Box3(this.p1.clone().add(new D.Vector3(-t, -t, -t)), this.p1.clone().add(new D.Vector3(t, t, t))), i = new D.Box3(this.p2.clone().add(new D.Vector3(-t, -t, -t)), this.p2.clone().add(new D.Vector3(t, t, t)));
        return e.union(i);
    }, Qt.prototype.prepareForEval = function() {
        this.valid_aabb || (this.l.set(this.p1, this.p2), this.valid_aabb = !0);
    }, Qt.prototype.getAreas = function(t) {
        if (this.valid_aabb) return [ {
            aabb: this.computeDistanceAABB(t),
            bv: new Xt(this.p1, this.p2, t, t, this.acc, this.acc),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, Qt.prototype.value = (Wt = new D.Vector3(), Zt = new D.Vector3(), function(t, e) {
        this.l.closestPointToPoint(t, !0, Wt), e.v = Zt.subVectors(t, Wt).length(), e.g && e.g.copy(Zt).divideScalar(e.v);
    });
    var Yt, $t = Qt, te = function(t, e) {
        Gt.call(this), this.p = t.clone(), this.r = e;
    };
    ((te.prototype = Object.create(Gt.prototype)).constructor = te).type = "SDFSphere", 
    r.register(te.type, te), te.prototype.getType = function() {
        return te.type;
    }, te.prototype.toJSON = function() {
        var t = Gt.prototype.toJSON.call(this);
        return t.p = {
            x: this.p.x,
            y: this.p.y,
            z: this.p.z
        }, t.r = this.r, t;
    }, te.fromJSON = function(t) {
        return new te(new D.Vector3(t.p.x, t.p.y, t.p.z), t.r);
    }, te.prototype.setRadius = function(t) {
        this.r = t, this.invalidAABB();
    }, te.prototype.getRadius = function() {
        return this.r;
    }, te.prototype.setPosition = function(t) {
        this.p.copy(t), this.invalidAABB();
    }, te.prototype.getPosition = function() {
        return this.p;
    }, te.prototype.computeDistanceAABB = function(t) {
        return new D.Box3(this.p.clone().add(new D.Vector3(-this.r - t, -this.r - t, -this.r - t)), this.p.clone().add(new D.Vector3(this.r + t, this.r + t, this.r + t)));
    }, te.prototype.prepareForEval = function() {
        this.valid_aabb || (this.valid_aabb = !0);
    }, te.prototype.getAreas = function(t) {
        if (this.valid_aabb) return [ {
            aabb: this.computeDistanceAABB(t),
            bv: new it(this.p, this.r + t, this.r / (this.r + t)),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, te.prototype.value = (Yt = new D.Vector3(), function(t, e) {
        if (!this.valid_aabb) throw "Error : PrepareForEval should have been called";
        Yt.subVectors(t, this.p);
        var i = Yt.length();
        e.v = i - this.r, e.g && e.g.copy(Yt).multiplyScalar(1 / i);
    });
    var ee, ie, re = te, se = function(t, e, i, r) {
        Gt.call(this), this.p1 = t.clone(), this.p2 = e.clone(), this.r1 = i, this.r2 = r, 
        this.r1 = this.r1, this.rdiff = this.r2 - this.r1, this.unit_dir = new D.Vector3().subVectors(this.p2, this.p1), 
        this.lengthSq = this.unit_dir.lengthSq(), this.length = this.unit_dir.length(), 
        this.unit_dir.normalize();
    };
    ((se.prototype = Object.create(Gt.prototype)).constructor = se).type = "SDFCapsule", 
    r.register(se.type, se), se.prototype.getType = function() {
        return se.type;
    }, se.prototype.toJSON = function() {
        var t = Gt.prototype.toJSON.call(this);
        return t.p1 = {
            x: this.p1.x,
            y: this.p1.y,
            z: this.p1.z
        }, t.r1 = this.r1, t.p2 = {
            x: this.p2.x,
            y: this.p2.y,
            z: this.p2.z
        }, t.r2 = this.r2, t;
    }, se.fromJSON = function(t) {
        ScalisVertex.fromJSON(t.v[0]);
        return new se(new D.Vector3(t.p1.x, t.p1.y, t.p1.z), new D.Vector3(t.p2.x, t.p2.y, t.p2.z), t.r1, t.r2);
    }, se.prototype.setRadius1 = function(t) {
        this.r1 = t, this.invalidAABB();
    }, se.prototype.setRadius2 = function(t) {
        this.r1 = t, this.invalidAABB();
    }, se.prototype.getRadius1 = function() {
        return this.r1;
    }, se.prototype.getRadius2 = function() {
        return this.r2;
    }, se.prototype.setPosition1 = function(t) {
        this.p1.copy(t), this.invalidAABB();
    }, se.prototype.setPosition2 = function(t) {
        this.p2.copy(t), this.invalidAABB();
    }, se.prototype.getPosition1 = function() {
        return this.p1;
    }, se.prototype.getPosition2 = function() {
        return this.p2;
    }, se.prototype.computeDistanceAABB = function(t) {
        var e = new D.Box3(this.p1.clone().add(new D.Vector3(-this.r1 - t, -this.r1 - t, -this.r1 - t)), this.p1.clone().add(new D.Vector3(this.r1 + t, this.r1 + t, this.r1 + t))), i = new D.Box3(this.p2.clone().add(new D.Vector3(-this.r2 - t, -this.r2 - t, -this.r2 - t)), this.p2.clone().add(new D.Vector3(this.r2 + t, this.r2 + t, this.r2 + t)));
        return e.union(i);
    }, se.prototype.prepareForEval = function() {
        this.valid_aabb || (this.valid_aabb = !0);
    }, se.prototype.getAreas = function(t) {
        if (this.valid_aabb) return [ {
            aabb: this.computeDistanceAABB(t),
            bv: new Xt(this.p1, this.p2, this.r1 + t, this.r2 + t, this.r1 / (this.r1 + t), this.r2 / (this.r2 + t)),
            obj: this
        } ];
        throw "ERROR : Cannot get area of invalid primitive";
    }, se.prototype.value = (ee = new D.Vector3(), ie = new D.Vector3(), function(t, e) {
        ee.subVectors(t, this.p1);
        var i = ee.lengthSq(), r = ee.dot(this.unit_dir), s = r + -Math.sqrt(Math.max(0, i - r * r)) / this.length * (this.r1 - this.r2), o = D._Math.clamp(s / this.length, 0, 1);
        ie.copy(this.p1).lerp(this.p2, o);
        var n = ee.subVectors(t, ie).length();
        e.v = n - (o * this.r2 + (1 - o) * this.r1), e.g && e.g.copy(ee).divideScalar(n);
    });
    var oe = se, ne = {
        EdgeVMap: [ [ 0, 4 ], [ 1, 5 ], [ 2, 6 ], [ 3, 7 ], [ 0, 2 ], [ 1, 3 ], [ 4, 6 ], [ 5, 7 ], [ 0, 1 ], [ 2, 3 ], [ 4, 5 ], [ 6, 7 ] ],
        VertexTopo: [ [ 0, 0, 0 ], [ 0, 0, 1 ], [ 0, 1, 0 ], [ 0, 1, 1 ], [ 1, 0, 0 ], [ 1, 0, 1 ], [ 1, 1, 0 ], [ 1, 1, 1 ] ]
    }, he = function(t, e, i, r) {
        if (D.Box2.call(this, t, e), null == i) {
            var s = Math.max(this.max.x - this.min.x, this.max.y - this.min.y);
            this.nice_acc = s <= 0 ? 1e7 : s;
        } else this.nice_acc = i;
        this.raw_acc = null == r ? this.nice_acc : r;
    };
    (he.prototype = Object.create(D.Box2.prototype)).union = function(t) {
        D.Box2.prototype.union.call(this, t), this.raw_acc = Math.min(t.raw_acc, this.raw_acc), 
        this.nice_acc = Math.min(t.nice_acc, this.nice_acc);
    }, he.prototype.getRawAcc = function() {
        return this.raw_acc;
    }, he.prototype.getNiceAcc = function() {
        return this.nice_acc;
    }, he.prototype.setRawAcc = function(t) {
        this.raw_acc = Math.max(0, t);
    }, he.prototype.setNiceAcc = function(t) {
        this.nice_acc = Math.max(0, t);
    }, he.prototype.toString = function() {
        return "(" + this.min.x.toFixed(2) + ", " + this.min.y.toFixed(2) + ") -> (" + this.max.x.toFixed(2) + ", " + this.max.y.toFixed(2) + ") ";
    }, he.prototype.set = function(t, e, i, r, s, o) {
        this.min.set(t, e), this.max.set(i, r), void 0 !== s && (this.nice_acc = s), void 0 !== o && (this.raw_acc = o);
    }, he.prototype.getMinCorner = function() {
        return this.min;
    };
    var ae, ce, pe, le, ue = function(t, e) {
        e = e || {};
        this.blobtree = t, this.detail_ratio = e.detailRatio ? Math.max(.01, e.detailRatio) : 1, 
        e.convergence ? (this.convergence = e.convergence, this.convergence.ratio = this.convergence.ratio || .01, 
        this.convergence.step = this.convergence.step || 10) : this.convergence = null, 
        this.reso = new Int32Array(3), this.steps = {
            x: null,
            y: null,
            z: null
        }, this.curr_steps = {
            x: 0,
            y: 0,
            z: 0
        }, this.curr_step_vol = 0, this.values_xy = [ null, null ], this.vertices_xy = [ null, null ], 
        this.areas = [], this.min_acc = 1, this.values = new Array(8), this.x = 0, this.y = 0, 
        this.z = 0, this.mask = 0, this.edge_cross = [ !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1, !1 ], 
        this.vertex = new D.Vector3(0, 0, 0), this.vertex_n = new D.Vector3(0, 0, 0), this.vertex_m = new _(null, null, null), 
        this.extended = !1, this.dis_o_aabb = new D.Box3(), this.ext_p = new D.Vector3(), 
        this.geometry = null;
    };
    ue.prototype.initGeometry = function() {
        this.geometry = {
            position: [],
            normal: [],
            color: [],
            metalness: [],
            roughness: [],
            nVertices: 0,
            faces: [],
            nFaces: 0,
            addVertex: function(t) {
                this.position.push(t.p.x, t.p.y, t.p.z), this.normal.push(t.n.x, t.n.y, t.n.z), 
                this.color.push(t.c.r, t.c.g, t.c.b), this.roughness.push(t.r), this.metalness.push(t.m), 
                this.nVertices++;
            },
            addFace: function(t, e, i) {
                this.faces.push(t, e, i), this.nFaces++;
            }
        };
    }, ue.prototype.buildResultingBufferGeometry = function() {
        var t = new D.BufferGeometry();
        return t.addAttribute("position", new D.BufferAttribute(new Float32Array(this.geometry.position), 3)), 
        t.addAttribute("normal", new D.BufferAttribute(new Float32Array(this.geometry.normal), 3)), 
        t.addAttribute("color", new D.BufferAttribute(new Float32Array(this.geometry.color), 3)), 
        t.addAttribute("roughness", new D.BufferAttribute(new Float32Array(this.geometry.roughness), 1)), 
        t.addAttribute("metalness", new D.BufferAttribute(new Float32Array(this.geometry.metalness), 1)), 
        t.setIndex(new D.BufferAttribute(65535 < this.geometry.nVertices ? new Uint32Array(this.geometry.faces) : new Uint16Array(this.geometry.faces), 1)), 
        t;
    }, ue.prototype.setFrontToZero = function() {
        for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = 0;
    }, ue.prototype.setFrontToMinus = function() {
        for (var t = 0; t < this.values_xy[1].length; ++t) this.values_xy[1][t] = -1;
    }, ue.prototype.setFrontToZeroIfMinus = function() {
        for (var t = 0; t < this.values_xy[1].length; ++t) -1 === this.values_xy[1][t] && (this.values_xy[1][t] = 0);
    }, ue.prototype.interpolateInBox = function(t, e, i, r, s, o, n) {
        var h = this.values_xy[1], a = s - r, c = n - o;
        if (1 < a) for (var p = h[(_ = o * this.reso[0]) + r], l = (h[_ + s] - p) / a, u = 1; u < a; ++u) -1 === h[_ + r + u] && (h[_ + r + u] = p + u * l);
        if (1 < c) {
            var _;
            for (p = h[(_ = n * this.reso[0]) + r], l = (h[_ + s] - p) / a, u = 1; u < a; ++u) -1 === h[_ + r + u] && (h[_ + r + u] = p + u * l);
            for (u = 0; u <= a; ++u) {
                p = h[o * this.reso[0] + r + u], l = (h[n * this.reso[0] + r + u] - p) / c;
                for (var v = 1; v < c; ++v) -1 === h[(o + v) * this.reso[0] + r + u] && (h[(o + v) * this.reso[0] + r + u] = p + v * l);
            }
        }
    }, ue.prototype.computeFrontValAt = function(t, e, i, r, s) {
        this.computeFrontValAtClosure(t, e, i, r, s);
    }, ue.prototype.computeFrontValAtClosure = (ae = {
        v: 0
    }, ce = new D.Vector3(), function(t, e, i, r, s) {
        var o = s * this.reso[0] + r;
        ae.v = this.blobtree.getNeutralValue(), -1 === this.values_xy[1][o] && (ce.set(t + r * this.min_acc, e + s * this.min_acc, i), 
        this.blobtree.value(ce, ae), this.values_xy[1][o] = ae.v);
    }), ue.prototype.computeFrontValAtBoxCorners = function(t, e, i, r, s) {
        this.computeFrontValAt(t, e, i, r.x, r.y), this.computeFrontValAt(t, e, i, r.x, s.y), 
        this.computeFrontValAt(t, e, i, s.x, r.y), this.computeFrontValAt(t, e, i, s.x, s.y);
    }, ue.prototype.computeFrontValInBox = function(t, e, i, r, s) {
        for (var o = r.x; o <= s.x; ++o) for (var n = r.y; n <= s.y; ++n) this.computeFrontValAt(t, e, i, o, n);
    }, ue.prototype.setFrontValZeroInBox = function(t, e) {
        for (var i = t.x; i <= e.x; ++i) for (var r = t.y; r <= e.y; ++r) this.values_xy[1][r * this.reso[0] + i] = 0;
    }, ue.prototype.computeBoxMask = function(t, e) {
        var i = 0;
        return i |= this.values_xy[1][t.y * this.reso[0] + t.x] > this.blobtree.getIsoValue() ? 1 : 0, 
        i |= this.values_xy[1][t.y * this.reso[0] + e.x] > this.blobtree.getIsoValue() ? 2 : 0, 
        i |= this.values_xy[1][e.y * this.reso[0] + e.x] > this.blobtree.getIsoValue() ? 4 : 0, 
        i |= this.values_xy[1][e.y * this.reso[0] + t.x] > this.blobtree.getIsoValue() ? 8 : 0;
    }, ue.prototype.checkZeroBox = function(t, e) {
        return this.values_xy[1][t.y * this.reso[0] + t.x] + this.values_xy[1][t.y * this.reso[0] + e.x] + this.values_xy[1][e.y * this.reso[0] + e.x] + this.values_xy[1][e.y * this.reso[0] + t.x];
    }, ue.prototype.recursiveBoxComputation = function(t, e, i, r, s) {
        var o = null, n = new D.Vector2(Math.round(r.max.x - r.min.x), Math.round(r.max.y - r.min.y));
        if (1 < n.x && n.x >= n.y) {
            var h = r.min.x + Math.floor(n.x / 2);
            o = [ new he(r.min, new D.Vector2(h, r.max.y), 1e4, 1e4), new he(new D.Vector2(h, r.min.y), r.max, 1e4, 1e4) ], 
            this.computeFrontValAt(t, e, i, h, r.min.y), this.computeFrontValAt(t, e, i, h, r.max.y);
        } else {
            if (!(1 < n.y)) return;
            var a = r.min.y + Math.floor(n.y / 2);
            o = [ new he(r.min, new D.Vector2(r.max.x, a), 1e4, 1e4), new he(new D.Vector2(r.min.x, a), r.max, 1e4, 1e4) ], 
            this.computeFrontValAt(t, e, i, r.min.x, a), this.computeFrontValAt(t, e, i, r.max.x, a);
        }
        for (var c = [ [], [] ], p = 0; p < s.length; ++p) for (var l = 0; l < o.length; ++l) o[l].intersectsBox(s[p]) && (o[l].setRawAcc(Math.min(o[l].getRawAcc(), s[p].getRawAcc())), 
        o[l].setNiceAcc(Math.min(o[l].getNiceAcc(), s[p].getNiceAcc())), c[l].push(s[p]));
        for (l = 0; l < o.length; ++l) {
            var u = o[l], _ = u.getSize(new D.Vector3());
            if (0 === c[l].length) this.setFrontValZeroInBox(u.min, u.max); else if (_.x <= u.getRawAcc() && _.y <= u.getRawAcc()) {
                var v = this.computeBoxMask(u.min, u.max);
                15 === v || 0 === v ? this.interpolateInBox(t, e, i, u.min.x, u.max.x, u.min.y, u.max.y) : _.x <= u.getNiceAcc() && _.y <= u.getNiceAcc() ? this.interpolateInBox(t, e, i, u.min.x, u.max.x, u.min.y, u.max.y) : this.recursiveBoxComputation(t, e, i, u, c[l]);
            } else this.recursiveBoxComputation(t, e, i, u, c[l]);
        }
    }, ue.prototype.computeFrontValues = function(t, e, i) {
        this.setFrontToMinus();
        var r = this.blobtree.getAreas(), s = new he();
        s.makeEmpty();
        for (var o = [], n = 0; n < r.length; ++n) {
            var h = Math.round(r[n].bv.getMinRawAcc() * this.detail_ratio / this.min_acc), a = Math.round(r[n].bv.getMinAcc() * this.detail_ratio / this.min_acc), c = Math.max(0, Math.floor((r[n].aabb.min.x - t) / this.min_acc)), p = Math.max(0, Math.floor((r[n].aabb.min.y - e) / this.min_acc)), l = Math.min(this.reso[0] - 1, Math.ceil((r[n].aabb.max.x - t) / this.min_acc)), u = Math.min(this.reso[1] - 1, Math.ceil((r[n].aabb.max.y - e) / this.min_acc));
            o.push(new he(new D.Vector2(c, p), new D.Vector2(l, u), a, h)), s.union(o[o.length - 1]);
        }
        s.intersect(new he(new D.Vector2(0, 0), new D.Vector2(this.reso[0], this.reso[1]), s.getNiceAcc(), s.getRawAcc())), 
        this.computeFrontValAtBoxCorners(t, e, i, s.min, s.max), this.recursiveBoxComputation(t, e, i, s, o), 
        this.setFrontToZeroIfMinus();
    }, ue.prototype.getMinAcc = function(t) {
        for (var e = this.blobtree.getAreas(), i = Number.MAX_VALUE, r = 0; r < e.length; r++) {
            var s = e[r];
            if (s.aabb.intersectsBox(t) && s.bv) {
                var o = s.bv.getMinAcc();
                o < i && (i = o);
            }
        }
        return i * this.detail_ratio;
    }, ue.prototype.getMaxAcc = function(t) {
        for (var e = this.blobtree.getAreas(), i = 0, r = 0; r < e.length; r++) {
            var s = e[r];
            if (s.aabb.intersectsBox(t) && s.bv) {
                var o = s.bv.getMinAcc();
                i < o && (i = o);
            }
        }
        return i * this.detail_ratio;
    }, ue.prototype.compute = function(t, e, i) {
        this.initGeometry(), this.progress = i || function(t) {};
        var r = new Date();
        this.blobtree.prepareForEval();
        var s = null;
        if (s = t ? t.clone() : this.blobtree.getAABB(), this.extended = void 0 !== e && e, 
        this.extended) {
            for (var o = s.getSize(new D.Vector3()), n = Math.min(Math.min(this.getMinAcc(s), o[0]), Math.min(o[1], o[2])), h = s.clone(), a = s.clone(), c = [ "x", "y", "z" ], p = 0; p < c.length; ++p) {
                h.max[c[p]] = s.min[c[p]] + n;
                var l = this.getMaxAcc(h);
                0 !== l && (a.min[c[p]] = a.min[c[p]] - l), h.max[c[p]] = s.max[c[p]] - n, 0 !== (l = this.getMaxAcc(h)) && (a.max[c[p]] = a.max[c[p]] + l);
            }
            s.copy(a);
        }
        var u = [], _ = [];
        if (t && (this.blobtree.externalTrim(s, u, _), this.blobtree.prepareForEval()), 
        this.areas = this.blobtree.getAreas(), 0 === this.areas.length) return this.progress(100), 
        new D.BufferGeometry();
        this.min_acc = 0 !== this.areas.length ? this.areas[0].bv.getMinAcc() : 1;
        for (var v = 0; v < this.areas.length; ++v) this.areas[v].bv.getMinAcc() < this.min_acc && (this.min_acc = this.areas[v].bv.getMinAcc());
        this.min_acc = this.min_acc * this.detail_ratio;
        var m = s.min, g = s.getSize(new D.Vector3());
        this.steps.z = new Float32Array(Math.ceil(g.z / this.min_acc) + 2);
        m.z;
        this.steps.z[0] = m.z;
        for (var y = 1, d = this.blobtree.getAreas(); this.steps.z[y - 1] < m.z + g.z; ) {
            var f = g.z;
            for (v = 0; v < d.length; ++v) f = Math.min(f, d[v].bv.getAxisProjectionMinStep("z", this.steps.z[y - 1]) * this.detail_ratio);
            this.steps.z[y] = this.steps.z[y - 1] + f, y++;
        }
        if (this.reso[2] = y, this.reso[0] = Math.ceil(g.x / this.min_acc) + 2, this.reso[1] = Math.ceil(g.y / this.min_acc) + 2, 
        this.extended) {
            v = 0;
            for (this.dis_o_aabb.set(new D.Vector3(-1, -1, -1), new D.Vector3(-1, -1, -1)); v < this.reso[2] && -1 === this.dis_o_aabb.min.z; ) this.steps.z[v] >= t.min.z && (this.dis_o_aabb.min.z = v), 
            v++;
            for (v > this.reso[2] - 1 && (this.dis_o_aabb.min.z = this.reso[2] - 1), v = this.reso[2] - 1; 0 <= v && -1 === this.dis_o_aabb.max.z; ) this.steps.z[v] < t.max.z && (this.dis_o_aabb.max.z = v), 
            v--;
            v < 0 && (this.dis_o_aabb.max.z = 0), this.dis_o_aabb.min.x = Math.round((t.min.x - s.min.x) / this.min_acc), 
            this.dis_o_aabb.min.y = Math.round((t.min.y - s.min.y) / this.min_acc), this.dis_o_aabb.max.x = this.reso[0] - 2 - Math.round((s.max.x - t.max.x) / this.min_acc), 
            this.dis_o_aabb.max.y = this.reso[1] - 2 - Math.round((s.max.y - t.max.y) / this.min_acc);
        }
        this.values_xy[0] = new Float32Array(this.reso[0] * this.reso[1]), this.values_xy[1] = new Float32Array(this.reso[0] * this.reso[1]), 
        this.vertices_xy[0] = new Int32Array(this.reso[0] * this.reso[1]), this.vertices_xy[1] = new Int32Array(this.reso[0] * this.reso[1]);
        var b = new D.Box3();
        this.computeFrontValues(m.x, m.y, m.z);
        for (var w = 0, x = 0; x < this.reso[2] - 1; ++x) {
            var V = this.values_xy[0];
            this.values_xy[0] = this.values_xy[1], this.values_xy[1] = V, V = this.vertices_xy[0], 
            this.vertices_xy[0] = this.vertices_xy[1], this.vertices_xy[1] = V;
            var A = this.steps.z[x + 1];
            b.set(new D.Vector3(m.x, m.y, A - this.min_acc / 64), new D.Vector3(m.x + this.reso[0] * this.min_acc, m.y + this.reso[1] * this.min_acc, A + this.min_acc / 64)), 
            this.blobtree.internalTrim(b), this.blobtree.prepareForEval(), this.computeFrontValues(m.x, m.y, A), 
            this.blobtree.internalUntrim(b), this.blobtree.prepareForEval(), this.z = this.steps.z[x], 
            this.curr_steps.z = this.steps.z[x + 1] - this.steps.z[x], this.curr_steps.x = this.min_acc, 
            this.curr_steps.y = this.min_acc, this.curr_step_vol = this.curr_steps.x * this.curr_steps.y * this.curr_steps.z;
            for (var S = 0; S < this.reso[1] - 1; ++S) for (var M = 0; M < this.reso[0] - 1; ++M) this.y = m.y + S * this.min_acc, 
            this.fetchAndTriangulate(M, S, x, m);
            Math.round(100 * x / this.reso[2]) > w && (w = Math.round(100 * x / this.reso[2]), 
            this.progress(w));
        }
        t && (this.blobtree.untrim(u, _), this.blobtree.prepareForEval());
        var T = new Date();
        return console.log("Sliding Marching Cubes computed in " + (T - r) + "ms"), this.values_xy[0] = null, 
        this.values_xy[1] = null, this.vertices_xy[0] = null, this.vertices_xy[1] = null, 
        this.progress(100), this.buildResultingBufferGeometry();
    }, ue.prototype.fetchAndTriangulate = function(t, e, i, r) {
        var s = e * this.reso[0] + t, o = (e + 1) * this.reso[0] + t;
        this.values[0] = this.values_xy[0][s], this.values[1] = this.values_xy[1][s], this.values[2] = this.values_xy[0][o], 
        this.values[3] = this.values_xy[1][o], this.values[4] = this.values_xy[0][s + 1], 
        this.values[5] = this.values_xy[1][s + 1], this.values[6] = this.values_xy[0][o + 1], 
        this.values[7] = this.values_xy[1][o + 1], this.computeMask(), 0 !== this.mask && 255 !== this.mask && (this.x = r.x + t * this.min_acc, 
        this.computeVertex(), this.geometry.addVertex({
            p: this.vertex,
            n: this.vertex_n,
            c: this.vertex_m.getColor(),
            r: this.vertex_m.getRoughness(),
            m: this.vertex_m.getMetalness()
        }), this.vertices_xy[1][s] = this.geometry.nVertices - 1, this.triangulate(t, e, i));
    }, ue.prototype.pushDirectFaces = function(t, e, i, r) {
        this.geometry.addFace(t, e, i), this.geometry.addFace(i, r, t);
    }, ue.prototype.pushUndirectFaces = function(t, e, i, r) {
        this.geometry.addFace(i, e, t), this.geometry.addFace(t, r, i);
    }, ue.prototype.triangulate = function(t, e, i) {
        var r = e * this.reso[0] + t;
        if (this.edge_cross[0] && 0 !== e && 0 !== i) {
            var s = this.vertices_xy[1][r], o = this.vertices_xy[1][(e - 1) * this.reso[0] + t], n = this.vertices_xy[0][(e - 1) * this.reso[0] + t], h = this.vertices_xy[0][r];
            1 & this.mask ? this.pushDirectFaces(s, o, n, h) : this.pushUndirectFaces(s, o, n, h);
        }
        if (this.edge_cross[4] && 0 !== t && 0 !== i) {
            s = this.vertices_xy[1][r], o = this.vertices_xy[0][r], n = this.vertices_xy[0][r - 1], 
            h = this.vertices_xy[1][r - 1];
            1 & this.mask ? this.pushDirectFaces(s, o, n, h) : this.pushUndirectFaces(s, o, n, h);
        }
        if (this.edge_cross[8] && 0 !== t && 0 !== e) {
            s = this.vertices_xy[1][r], o = this.vertices_xy[1][r - 1], n = this.vertices_xy[1][(e - 1) * this.reso[0] + t - 1], 
            h = this.vertices_xy[1][(e - 1) * this.reso[0] + t];
            1 & this.mask ? this.pushDirectFaces(s, o, n, h) : this.pushUndirectFaces(s, o, n, h);
        }
    }, ue.prototype.computeVertex = function() {
        this.computeVertexClosure();
    }, ue.prototype.computeVertexClosure = (pe = {
        v: null,
        g: new D.Vector3(0, 0, 0),
        m: new _(null, null, null)
    }, le = new D.Vector3(), function() {
        pe.v = this.blobtree.getNeutralValue();
        var t = 0;
        this.vertex.set(0, 0, 0);
        for (var e = 0; e < 12; ++e) {
            var i = ne.EdgeVMap[e][0], r = ne.EdgeVMap[e][1], s = ne.VertexTopo[i], o = ne.VertexTopo[r], n = this.values[i], h = this.values[r];
            if (this.edge_cross[e] = n > this.blobtree.getIsoValue() != h > this.blobtree.getIsoValue(), 
            this.edge_cross[e]) {
                ++t;
                var a = h - n, c = 0;
                1e-6 < Math.abs(a) && (c = (this.blobtree.getIsoValue() - n) / a, this.vertex.x += (1 - c) * s[0] + c * o[0], 
                this.vertex.y += (1 - c) * s[1] + c * o[1], this.vertex.z += (1 - c) * s[2] + c * o[2]);
            }
        }
        this.vertex.x = this.x + this.curr_steps.x * this.vertex.x / t, this.vertex.y = this.y + this.curr_steps.y * this.vertex.y / t, 
        this.vertex.z = this.z + this.curr_steps.z * this.vertex.z / t, this.convergence && (l.safeNewton3D(this.blobtree, this.vertex, this.blobtree.getIsoValue(), this.min_acc * this.convergence.ratio, this.convergence.step, this.min_acc, le), 
        this.vertex.copy(le)), this.blobtree.value(this.vertex, pe), pe.g.normalize(), this.vertex_n.copy(pe.g).multiplyScalar(-1), 
        this.vertex_m.copy(pe.m);
    }), ue.prototype.computeMask = function() {
        for (var t = this.mask = 0; t < 8; ++t) {
            var e = this.values[t];
            this.mask |= e > this.blobtree.getIsoValue() ? 1 << t : 0;
        }
    };
    var _e = ue;
    96 !== D.REVISION && console.warn("Blobtree library is currently made for THREE revision 96. Using any other revision may lead to unexpected behavior.");
    var ve = {
        version: "1.0.0"
    };
    return ve.Types = r, ve.Element = s, ve.Node = a, ve.RootNode = O, ve.RicciNode = N, 
    ve.DifferenceNode = q, ve.MinNode = R, ve.Primitive = I, ve.ScalisMath = K, ve.ScalisPrimitive = H, 
    ve.ScalisPoint = st, ve.ScalisSegment = ut, ve.ScalisTriangle = Nt, ve.ScalisVertex = W, 
    ve.DistanceFunctor = zt, ve.Poly6DistanceFunctor = Et, ve.SDFRootNode = It, ve.SDFPrimitive = Gt, 
    ve.SDFPoint = Lt, ve.SDFSegment = $t, ve.SDFSphere = re, ve.SDFCapsule = oe, ve.Material = _, 
    ve.Accuracies = tt, ve.Area = Y, ve.AreaScalisSeg = pt, ve.AreaScalisTri = kt, ve.AreaSphere = it, 
    ve.AreaCapsule = Xt, ve.SlidingMarchingCubes = _e, ve;
});
